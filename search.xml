<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>How to Read a Computer Science Research Paper</title>
    <url>/2022/03/19/HowToReadCSPaper/</url>
    <content><![CDATA[<h3 id="Publication-Venues"><a href="#Publication-Venues" class="headerlink" title="Publication Venues"></a>Publication Venues</h3><ul>
<li>General : ACM , IEEE , AAAI , ACL</li>
<li>Specifically Recommended By CCF : <strong><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation/By_category/</a></strong></li>
</ul>
<blockquote>
<p>中国计算机学会（China Computer Federation）</p>
</blockquote>
<h3 id="Different-Types-of-CS-Research-Paper"><a href="#Different-Types-of-CS-Research-Paper" class="headerlink" title="Different Types of CS Research Paper"></a>Different Types of CS Research Paper</h3><p>There are three basic types of CS research paper: <strong>theoretical</strong>, <strong>engineering</strong> and <strong>empirical</strong>.</p>
<ul>
<li>A theoretical paper describes a theory or algorithm or provides a mathematical proof for some hypothesis.</li>
<li>An engineering paper describes an implementation of an algorithm, or part or all of a computer system or application. Engineering papers are now frequently required to include descriptions of system evaluation.</li>
<li>An empirical paper describes an experiment designed to test some hypothesis.</li>
</ul>
<span id="more"></span>



<h3 id="Taxonomy-of-Scientific-Papers"><a href="#Taxonomy-of-Scientific-Papers" class="headerlink" title="Taxonomy of Scientific Papers"></a>Taxonomy of Scientific Papers</h3><ul>
<li><p>Conference Papers</p>
<ul>
<li><p>Review : YES , peer-reviewed , the threshold depends on the conference</p>
</li>
<li><p>Goal : Publish a finished work with possible forthcoming research</p>
</li>
<li><p>Size : 8 - 20 Pages</p>
</li>
</ul>
</li>
<li><p>Journal Papers</p>
<ul>
<li><p>Review : YES , peer-reviewed , more longer than Conference Papers</p>
</li>
<li><p>Goal : Publish a present completed work</p>
</li>
<li><p>Size : 15 Pages</p>
</li>
</ul>
</li>
</ul>
<h3 id="How-call-I-tell-whether-a-research-paper-is-good-before-I-read-it"><a href="#How-call-I-tell-whether-a-research-paper-is-good-before-I-read-it" class="headerlink" title="How call I tell whether a research paper is good before I read it?"></a>How call I tell whether a research paper is good before I read it?</h3><p>Here are some indicators of a good research paper:</p>
<ul>
<li><ol>
<li>The problem the paper addresses is clearly stated, both in the abstract and early on in the paper itself. The technical importance and broader impacts of the paper are described. </li>
</ol>
</li>
<li><ol start="2">
<li>The paper includes a clear description of the experiment, system or theory the problem addresses. This is usually the second section of the paper. </li>
</ol>
</li>
<li><ol start="3">
<li>The paper describes and analyzes the results of the work described (either experimental or evaluation results).</li>
</ol>
</li>
<li><ol start="4">
<li>The authors have some sound, non-trivial ideas for future work. This usually appears at the end of the paper. </li>
</ol>
</li>
<li><ol start="5">
<li>Related work is described and cited correctly. You can get an idea of this by looking at the list of references at the end of the paper. </li>
</ol>
</li>
</ul>
<p>If you know that a researcher has been working in an area for a while, that is usually an indicator that the research is sound; however, do not underestimate the contributions of people new to a field or the impact of politics on research.</p>
<h3 id="Read-with-“three-pass”-method"><a href="#Read-with-“three-pass”-method" class="headerlink" title="Read with “three-pass” method"></a>Read with “three-pass” method</h3><p>The key idea is that you should read the paper in up to three passes, instead of starting at the beginning and plowing your way to the end. Each pass accomplishes specific goals and builds upon the previous pass:</p>
<ul>
<li>The first pass gives you a <strong>general idea</strong> about the paper.</li>
<li>The second pass lets you <strong>grasp the paper’s content</strong>, but not its details. </li>
<li>The third pass helps you <strong>understand the paper in depth</strong>.　</li>
</ul>
<h4 id="THE-FIRST-PASS"><a href="#THE-FIRST-PASS" class="headerlink" title="THE FIRST PASS"></a>THE FIRST PASS</h4><p>This pass should take about five to ten minutes and consists of the following steps:</p>
<ol>
<li> Carefully read the <strong>title</strong>, <strong>abstract</strong>, and <strong>introduction</strong> </li>
<li> Read the section and sub-section <strong>headings</strong>, but ignore everything else </li>
<li> Read the <strong>conclusions</strong></li>
<li> Glance over the <strong>references</strong>, mentally ticking off the ones you’ve already read</li>
</ol>
<h4 id="THE-SECOND-PASS"><a href="#THE-SECOND-PASS" class="headerlink" title="THE SECOND PASS"></a>THE SECOND PASS</h4><ol>
<li><strong>Look carefully at the figures, diagrams and other illustrations in the paper</strong>. Pay special attention to graphs. Are the axes properly labeled? Are results shown with error bars, so that conclusions are statistically significant? Common mistakes like these will separate rushed, shoddy work from the truly excellent. </li>
<li><strong>Remember to mark relevant unread references for further reading</strong> (this is a good way to learn more about the background of the paper).</li>
</ol>
<p>The second pass should take up to an hour.</p>
<h4 id="THE-THIRD-PASS"><a href="#THE-THIRD-PASS" class="headerlink" title="THE THIRD PASS"></a>THE THIRD PASS</h4><p>This pass requires great attention to detail. <strong>You should identify and challenge every assumption in every statement.</strong> Moreover, you should think about how you yourself would present a particular idea. This comparison of the actual with the virtual lends a sharp insight into the proof and presentation techniques in the paper and you can very likely add this to your repertoire of tools. During this pass, you should also jot down ideas for future work.</p>
<p>This pass can take about four or five hours for beginners, and about an hour for an experienced reader.</p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/2021/03/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt+Enter</td>
<td>导入包，错误修复</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制当前行</td>
</tr>
<tr>
<td>Ctrl+Alt+L（自定义：Alt+F）</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>单行注释</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>多行注释</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>自动生成代码，get，set方法</td>
</tr>
<tr>
<td>ALt+Shift+上下箭头</td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE重点</title>
    <url>/2021/04/14/JavaSE%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h5 id="1-error-和-exception-有啥区别"><a href="#1-error-和-exception-有啥区别" class="headerlink" title="1.error 和 exception 有啥区别"></a>1.error 和 exception 有啥区别</h5><h5 id="2-hash-扩容"><a href="#2-hash-扩容" class="headerlink" title="2.hash 扩容"></a>2.hash 扩容</h5><span id="more"></span>

<hr>
<h5 id="3-Java-和-JavaScript-有啥区别"><a href="#3-Java-和-JavaScript-有啥区别" class="headerlink" title="3.Java 和 JavaScript 有啥区别"></a>3.Java 和 JavaScript 有啥区别</h5><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a></p>
</blockquote>
<ul>
<li><p>它们的相同之处包括：</p>
<ul>
<li>它们的语法和 C 语言都很相似；</li>
<li>它们都是面向对象的（虽然实现的方式略有不同）；</li>
<li>JavaScript 在设计时参照了 Java 的命名规则；   </li>
</ul>
</li>
<li><p>它们的不同之处包括：</p>
<ul>
<li> JavaScript 是动态类型语言，而 Java 是静态类型语言；</li>
<li>JavaScript 是弱类型的，Java 属于强类型；</li>
<li>JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的；</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-final，finally，finalized-的区别"><a href="#4-final，finally，finalized-的区别" class="headerlink" title="4.final，finally，finalized 的区别"></a>4.final，finally，finalized 的区别</h5><h5 id="5-final的特点及应用"><a href="#5-final的特点及应用" class="headerlink" title="5.final的特点及应用"></a>5.final的特点及应用</h5><p>final可以修饰类/方法/局部变量/成员变量</p>
<ul>
<li><p>对于类来说：如果用final修饰，则当前类不能有任何子类，那么其中的所有成员方法都不能覆盖重写</p>
</li>
<li><p>对于方法来说：当用final来修饰方法时，则该方法是最终方法。</p>
</li>
</ul>
<blockquote>
<p>注意：对于类与方法来说，abstract与final不能同时使用。</p>
</blockquote>
<ul>
<li>对于局部变量来说：一次赋值，终身不变。同时，对于基本数据类型来说，不可变说的是数据不变。对于引用类型来说，不可变说的是地址值不变。</li>
<li> 对于成员变量来说：一定要进行手动赋值，要么通过构造方法赋值，要么直接赋值。</li>
</ul>
<hr>
<h5 id="6-修饰符使用范围"><a href="#6-修饰符使用范围" class="headerlink" title="6.修饰符使用范围"></a>6.修饰符使用范围</h5><table>
<thead>
<tr>
<th>关键字</th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本类当中/我自己</td>
<td>同一个包/我邻居</td>
<td>不同包子类/我儿子</td>
<td>不同包不同类/陌生人</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见命令</title>
    <url>/2021/03/23/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a>常见命令：</h4><p>pwd ： 查看当前路径</p>
<p>ls : 查看当前目录文件夹</p>
<p>mkdir ：创建<strong>文件夹</strong></p>
<p>rm：删除文件</p>
<p>touch：创建<strong>文件</strong></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora入门技巧</title>
    <url>/2021/03/22/Typora%E5%85%A5%E9%97%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>本篇文章主要就是记录一下MarkDown语法。md语法在所有支持 <code>.md</code> 的软件都是通用的，而快捷键是在<code>Typora</code>软件中适用的。</p>
<ol>
<li><strong>使用  <code>Ctrl+Shift+K</code>创建代码块：</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右下角 [选择语言]  ：</span><br><span class="line">                  输入 java &#x2F; c++ &#x2F; shell &#x2F; javascript 等任意语言</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<ol start="2">
<li><strong>使用   <code>&gt;</code>   进行引用，效果如下：</strong></li>
</ol>
<blockquote>
<p>   引用内容</p>
</blockquote>
<ol start="3">
<li><strong>使用  <code>#</code> 更改标题大小</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><strong>更改字体格式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">斜体        *文字内容*</span><br><span class="line">加粗       **文字内容**</span><br><span class="line">删除线      ~~文字内容~~</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <em>斜体</em>            <strong>加粗</strong>             <del>删除线</del></p>
</blockquote>
<ol start="5">
<li><strong>使用 <code>Ctrl+T</code> 建立表格</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + T</td>
<td align="left">新建表格</td>
</tr>
<tr>
<td align="left">双击Enter</td>
<td align="left">清除所有格式，另起一行</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left"><u>下划线</u></td>
</tr>
<tr>
<td align="left">Ctrl+B</td>
<td align="left"><strong>加粗</strong></td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left"><em>斜体</em></td>
</tr>
</tbody></table>
<ol start="6">
<li><strong>使用 <code>---</code>进行分割</strong></li>
</ol>
<hr>
<p>创建一条分割线   —</p>
<hr>
<ol start="7">
<li><strong>图片插入</strong>:  <code>Ctrl+Shift+I</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地图片</span></span><br><span class="line">[自定义图片名称]（图片路径）</span><br><span class="line">    </span><br><span class="line">ex: [我的照片]（/images/pic/mine.jpg）</span><br></pre></td></tr></table></figure>



<ol start="8">
<li><strong>超链接</strong>：<code>Ctrl+K</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超链接语法</span></span><br><span class="line"></span><br><span class="line">[我的blog](https:<span class="comment">//eniac286.github.io/)</span></span><br></pre></td></tr></table></figure>

<p>ex： <a href="https://eniac286.github.io/">我的blog</a></p>
<ol start="9">
<li><strong>列表</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无序列表：+ - * 均可创建</span></span><br><span class="line">- 目录<span class="number">1</span></span><br><span class="line">+ 目录<span class="number">2</span></span><br><span class="line">* 目录<span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目录1   </li>
</ul>
<ul>
<li>目录2</li>
<li>目录3</li>
</ul>
<ol start="10">
<li><strong>使用  <code>ctrl+shift+` </code>   创建特殊标记 ：</strong></li>
</ol>
<p>无特殊标记      <code>有特殊标记</code></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/26/java%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、理解设计模式"><a href="#一、理解设计模式" class="headerlink" title="一、理解设计模式"></a>一、理解设计模式</h2><h3 id="理解设计模式"><a href="#理解设计模式" class="headerlink" title="理解设计模式"></a>理解设计模式</h3><p>设计模式是软件开发人员经过长时间试错和应用总结出来的，解决特定问题的一系列方法。可以迅速提高代码的<strong>可读性、健壮性、扩展性。</strong></p>
<p>参考链接：<a href="https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html">https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html</a></p>
<blockquote>
<p><strong>策略模式</strong>定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。策略模式通常包含以下角色：1</p>
<ul>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>适配器模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>单例模式</strong>：设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<ul>
<li>这种模式涉及到一个单一的类，该类负责创建自己的对象，</li>
<li>同时确保只有单个对象被创建。</li>
<li>这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</li>
</ul>
</blockquote>
<h3 id="七大基本原则（SOLID）："><a href="#七大基本原则（SOLID）：" class="headerlink" title="七大基本原则（SOLID）："></a>七大基本原则（SOLID）：</h3><ol>
<li>单一职责原则 (Single Responsibility Principle)</li>
<li>开放-关闭原则 (Open-Closed Principle)</li>
<li>里氏替换原则 (Liskov Substitution Principle)</li>
<li>依赖倒转原则 (Dependence Inversion Principle)</li>
<li>接口隔离原则 (Interface Segregation Principle)</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li>
</ol>
<p>参考链接： <a href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>1、单例类只能有一个实例。</p>
</li>
<li><p>2、单例类必须自己创建自己的唯一实例。</p>
</li>
<li><p>3、单例类必须给所有其他对象提供这一实例。</p>
</li>
</ul>
<p><strong>懒汉式(线程不安全)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>**懒汉式(线程安全)**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">	 		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式(线程不安全):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static final instance &#x3D; new Singleton();</span><br><span class="line">	private singleton()&#123;&#125;;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双检锁/双重校验锁（DCL，即 double-checked locking）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronize(Singleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4.工厂模式"></a>4.工厂模式</h3><span id="more"></span>]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多线程练习</title>
    <url>/2021/03/19/%E5%B0%8F%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>两个10G的csv文件（t1.csv, t2.csv），两个csv文件里面表头为：id，name，grade</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id：      String类型</span><br><span class="line">name：    String类型</span><br><span class="line">grade：   String类型</span><br></pre></td></tr></table></figure>

<p>服务器内存只有1G，找出grade不为空，且grade数字大于90的数据，输出到当前目录下t3.csv文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 尹丹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2022/3/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File inputFile = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(inputFile));</span><br><span class="line">            <span class="comment">//跳过表头所在的行</span></span><br><span class="line">            reader.readLine();</span><br><span class="line">            <span class="comment">//按行读取文件</span></span><br><span class="line">            <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                String[] splitline = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">double</span> temp = Double.parseDouble(splitline[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">90</span>) &#123;</span><br><span class="line">                    writer.write(line);</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 尹丹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2022/3/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File outputFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\Yoon\\Desktop\\t3.csv&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(outputFile));</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Reader(<span class="string">&quot;C:\\Users\\Yoon\\Desktop\\t1.csv&quot;</span>, bufferedWriter);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Reader(<span class="string">&quot;C:\\Users\\Yoon\\Desktop\\t2.csv&quot;</span>, bufferedWriter);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影笔记</title>
    <url>/2022/02/04/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="01-了解数码相机"><a href="#01-了解数码相机" class="headerlink" title="01 了解数码相机"></a>01 了解数码相机</h2><h3 id="第1节-数码相机机身简介"><a href="#第1节-数码相机机身简介" class="headerlink" title="第1节 数码相机机身简介"></a>第1节 数码相机机身简介</h3><p><strong>单反相机</strong>工作时，光通过镜头进入机身，光线一分为二，一束光在反光镜上通过对焦机构进入五棱镜，之后再通过五棱镜到目镜里。通过光学取景器，可以取景、构图、对焦。另一束光传递到感应器，用于识别场景、测光和设定白平衡。按下快门时，反光镜抬起，快门帘打开，全部光线落在电子感光器上，被影像处理器处理后传输到储存卡中记录下来。</p>
<span id="more"></span>

<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050340856.png" alt="image-20220205034025473" style="zoom:50%;" />

<p><strong>无反相机</strong>工作时，光线通过镜头落在电子感光元件上，被影像处理器处理后传输到储存卡中记录下来。与单反相机不同的是取景方式，无反相机没有反光镜，所以取景也是通过电子感光元件——传感器取景，图像最终呈现在电子取景器（EVF）或者液晶屏上，这一点就好像数码单反相机使用实时取景一样。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050342083.png" alt="image-20220205034254951" style="zoom:50%;" />



<p><strong>传感器尺寸</strong>，又被称为画幅。1934年，柯达公司引入了一次性的胶卷盒，称为135胶卷，1表示一次性，35表示采用了35mm电影胶片。在刚刚进入数码时代的时候，相机厂商们都想做拥有35mm胶片大小传感器的单反相机，这个尺寸被大家称为<strong>35mm全画幅</strong>。</p>
<p>但是大家都遇到一个问题——贵！一旦采用，相机就没几个人能买得起了。从此单反相机中就有了两大传感器尺寸标准——全画幅和APS-C尺寸(23.5mm×15.6mm)。</p>
<h3 id="第2节-镜头简介"><a href="#第2节-镜头简介" class="headerlink" title="第2节 镜头简介"></a>第2节 镜头简介</h3><blockquote>
<p>佳能的EF 70-200mm f/2.8L IS USM II</p>
</blockquote>
<p>1．镜头种类</p>
<p>EF表示EOS相机卡口的镜头。其他的还有EF-S只适用于佳能APS-C画幅EOS相机的镜头；MP-E放大倍率在1倍以上的微距摄影镜头；TS-E移轴镜头。</p>
<p>2．焦距</p>
<p>70-200mm表示这是一个广角端为70mm，长焦端为200mm的变焦镜头。如果只有一个数值那么就是定焦镜头。</p>
<p>3．最大光圈</p>
<p>f/2.8表示这支镜头全焦段的最大光圈是恒定的2.8。有的镜头会有两个数值，分别表示广角端和长焦端的最大光圈。最大光圈表示在这个焦距的时候你可以使用的光圈最大有多大，如果想缩小光圈，自然也是可以的。</p>
<p>4．特性</p>
<p>L表示佳能的专业级镜头，同时镜头前端也会有红圈。IS表示具有防抖功能。USM表示具有超声波马达。II表示这是这个镜头的第二代产品。</p>
<p><strong>总结：光圈越大，单位时间内镜头的通光能力越强，这支镜头往往也越好</strong></p>
<h2 id="02-焦距与取景"><a href="#02-焦距与取景" class="headerlink" title="02 焦距与取景"></a>02 焦距与取景</h2><p> <strong>鱼眼 &lt; 超广角（28mm以下）&lt; 广角 &lt; 微距 &lt; 长焦 &lt; 超长焦（300mm以上）</strong></p>
<p><strong>24mm和28mm</strong></p>
<p>这就是一个标准的广角焦距，主要就是用来拍摄风景。</p>
<p><strong>35mm</strong></p>
<p>有人说这是大师的焦距，也被称为人文眼。简单地说就是拍摄人文最好的焦距。拍摄人文照片的时候需要主体和背景环境的关系，所以小广角的35mm既能够将背景囊括进来，又能突出人与环境的关系，这是拍摄人文的关键</p>
<p><strong>50mm</strong></p>
<p>这被称为标准镜头，拍摄人文、人像都是很好的，也是大师的焦距。</p>
<p><strong>85mm</strong></p>
<p>这是一个拍摄人像的焦距。能有很好的背景虚化效果，很好的画面裁切能力，还能保持和模特之间适当的交流距离。主要用于模特大头照或者特写。</p>
<p><strong>等效焦距</strong></p>
<p>传感器有大有小，会对这些实际焦距取景范围有截取，造成拍摄的视角与实际焦距原本应该有的视角不相同。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050410367.png" alt="image-20220205041015149" style="zoom:50%;" />



<p>实际上每个不同尺寸的传感器都有一个系数与之相对应，这个系数乘以实际焦距之后，就是等效焦距了。这个系数就叫<strong>镜头转换系数。</strong></p>
<p>全画幅：<strong>1.0</strong>x55mm=55mm</p>
<p>APS-C：<strong>1.5</strong>x55mm=82.5mm</p>
<h2 id="03-影调"><a href="#03-影调" class="headerlink" title="03 影调"></a>03 影调</h2><h3 id="第1节-什么是影调"><a href="#第1节-什么是影调" class="headerlink" title="第1节 什么是影调"></a>第1节 什么是影调</h3><p>那些本身就明亮的物体应该用高调表现；那些本身就黑的物体应该用低调表现。</p>
<p>本身就是高调的物体：雪、白馒头、白衣服、白纸、棉花……</p>
<p>本身就是低调的物体：煤炭、黑色皮鞋、黑色的衣服、夜晚的天空……</p>
<p><strong>大多数照片都是中间调，少数场景需要用高调或者低调来表现。</strong></p>
<h3 id="第2节-影调的量化"><a href="#第2节-影调的量化" class="headerlink" title="第2节 影调的量化"></a>第2节 影调的量化</h3><h4 id="曝光补偿-gt-gt-gt-gt"><a href="#曝光补偿-gt-gt-gt-gt" class="headerlink" title="曝光补偿&gt;&gt;&gt;&gt;"></a><strong>曝光补偿&gt;&gt;&gt;&gt;</strong></h4><p>其实在相机中有一个非常标准的量化体系——<strong>曝光补偿</strong>。</p>
<p>曝光补偿的意思就是，相机给你的曝光就是中间调的，你拍的东西亮呢，就往亮了补偿补偿。你拍的东西暗呢，就往暗了补偿补偿。中间调就不补偿。</p>
<h4 id="测光系统-gt-gt-gt-gt"><a href="#测光系统-gt-gt-gt-gt" class="headerlink" title="测光系统&gt;&gt;&gt;&gt;"></a><strong>测光系统&gt;&gt;&gt;&gt;</strong></h4><p>相机的测光系统主要可以分为三种：</p>
<p><strong>智能测光</strong></p>
<p>每个厂商叫的名称不同，但是一般都是默认项。推荐使用。</p>
<p><strong>中心重点平均测光</strong></p>
<p>就是重点考虑中心主体的曝光，然后加权其他背景的曝光。这曾经是很多人最常用的测光方式。但是后来的评价测光、矩阵测光、多重测光等更智能的方式出来之后，用的人逐渐少了。所以新手们，我觉得这个测光方式学不学都可以。</p>
<p><strong>点测光</strong></p>
<p>就是对画面中的一点测光，这个点一般很小，画面中1%～3%的面积，越高级的相机测光面积越小。在复杂光线环境的时候拍一个姑娘，最重要的就是保证姑娘脸是曝光正常的，所以对这姑娘的脸点测光，这个曝光参数就足够保证姑娘脸是好的。</p>
<h2 id="04-曝光补偿三要素"><a href="#04-曝光补偿三要素" class="headerlink" title="04 曝光补偿三要素"></a>04 曝光补偿三要素</h2><p>照片的影调=光线强度×<strong>光圈×快门×感光度</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050428814.png" alt="image-20220205042848707" style="zoom:50%;" />

<p>如果快门速度不变，光圈开大1挡，同时感光度降低1挡得到的照片的明暗程度是相同的，反之亦然。这就是<strong>互易律</strong>。</p>
<h2 id="05-相机模式"><a href="#05-相机模式" class="headerlink" title="05 相机模式"></a>05 相机模式</h2><p>一般来说摄影师的相机都有以下三种模式：</p>
<p><strong>Av、A挡 光圈优先</strong></p>
<p>摄影师设定影调（曝光补偿）和光圈，相机会自动选择合适的快门速度。</p>
<p><strong>Tv、S挡 快门优先</strong></p>
<p>摄影师设定影调（曝光补偿）和快门，相机会自动选择合适的光圈。</p>
<p><strong>M手动（手动控制光圈、快门）</strong></p>
<p>摄影师设定光圈、快门，相机告诉你影调将会是如何。</p>
<p>使用M挡手动曝光情况都是你无法使用相机测光的时候，其实等于你放弃了相机测光。所以请记住，往往在你无法使用相机测光的时候，才用M挡。</p>
<h2 id="06-光线"><a href="#06-光线" class="headerlink" title="06 光线"></a>06 光线</h2><h3 id="第1节-光线的特性"><a href="#第1节-光线的特性" class="headerlink" title="第1节 光线的特性"></a>第1节 光线的特性</h3><p><strong>顺光</strong></p>
<p>其实顺光不应过多地运用在人像摄影中。因为正面直射的光会消除面部的一切影子，使得面部趋于平面化，所以又叫平光。</p>
<p><strong>侧光</strong></p>
<p>侧光一般用在人物摄影的造型上。相比顺光会将人物拍成“大白脸”，侧光能够让人物的面部呈现立体效果。</p>
<p><strong>逆光</strong></p>
<p>逆光是很多摄影师进行创作的用光。使用逆光拍摄的时候，往往会有雾蒙蒙的感觉，并形成暖色调。</p>
<p><strong>色温</strong></p>
<p>蓝色是冷色，但是色温高；红色是暖色，但是色温低。</p>
<p>日光的色温大概是5500K。白纸放到日光下就是白色的。</p>
<p><strong>白平衡</strong></p>
<p>白平衡是相机机内处理的结果。说白了就是相机自己的后期。所以如果你拍摄RAW格式照片的话，可以在计算机中重新定义白平衡，重新调节。理论上是没有画质损失的（尽管实际可能有，但是也非常小，可忽略）。</p>
<blockquote>
<p>所以AWB+RAW拍摄，是一个既方便，又保险的组合。</p>
</blockquote>
<h3 id="第2节-布光方法"><a href="#第2节-布光方法" class="headerlink" title="第2节 布光方法"></a>第2节 布光方法</h3><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050444659.png" alt="image-20220205044427503" style="zoom:50%;" />

<p><strong>伦勃朗布光法</strong>有几个特点：</p>
<p>1．四分之三面部对着相机。让人物面向相机，缓慢变换角度，直到看不到一侧的耳朵为止。</p>
<p>2．架设主灯，强度要能使人面部正确曝光，方向为与人物面部方向同一侧45°左右。注意，要在人物面部形成三角形光区（以鼻子阴影、面颊阴影、下眼线为边长，围成的三角形亮区）。</p>
<p>3．架设辅灯。将面部阴影处柔化，并表现出细节。一般会使用4:1或者3:1的光比。</p>
<p>4．架设背景灯，打亮背景。如果有可能从人物斜后方放置一束比较集中的光，打在人物轮廓上，形成轮廓光。如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050446673.png" alt="image-20220205044609555" style="zoom:50%;" />



<p>伦勃朗布光法是适用于男性的。那么再提供一个适用于女性摄影的布光法——<strong>蝶形布光法</strong>。</p>
<p><strong>蝶形布光法</strong>的名字来源于布光法中的一个特点。类似于伦勃朗布光法中要找三角形光区，蝶形布光法就是要找这个蝶形。使用蝶形布光法的时候，主灯放置在人物正前方，但是处于比较高的位置。这与顶光不同。蝶形布光法的主灯是从上斜射下来的。这样在人物的鼻子下方就会形成一个阴影。随着主灯高度变化，阴影会在鼻子下面形成一个蝴蝶的形状。这时主灯的位置就可以确定了。</p>
<h2 id="07-摄影中的虚实"><a href="#07-摄影中的虚实" class="headerlink" title="07 摄影中的虚实"></a>07 摄影中的虚实</h2><p><strong>前帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），就闪光，闪完了之后等曝光时间一到后帘关闭（曝光结束）。这样就是一辆车移动，你拍摄车。开启快门就闪光了，车被闪光灯定在了画面中，然后长曝光继续曝，车往前走拉车线。这样就变成了车在后面，车线在前面的奇葩照片。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045502246.png" alt="image-20220205045502246" style="zoom:25%;" />



<p><strong>后帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），先踏踏实实曝着光。然后闪光灯闪了一下，定格画面，随即后帘关闭（曝光结束）。这样一辆车移动，你拍摄车。开启快门，先拉车线，然后马上快门关闭了，闪光灯突然把车定格住。就变成了车在前面，车线在后面的好画面了。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045429391.png" alt="image-20220205045429391" style="zoom:25%;" />

<h2 id="08-构图"><a href="#08-构图" class="headerlink" title="08 构图"></a>08 构图</h2><p><strong>居中构图</strong></p>
<p><strong>三分法构图</strong></p>
<p><strong>重复法</strong></p>
<p><strong>引导线</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050457311.png" alt="image-20220205045729070" style="zoom:25%;" />

<p><strong>三角构图</strong></p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>摘抄--3月24日</title>
    <url>/2021/03/24/%E6%91%98%E6%8A%84--3%E6%9C%8824%E6%97%A5/</url>
    <content><![CDATA[<p>过去的每一天都不曾消失，它们闪烁在未来的天幕上，成为个人的群星，构成属于你自己的浩瀚银河。</p>
<p>然后，在某一刻，哗啦一声，向你奔涌而来。</p>
<p>我相信，每个人心中，都存在对浩瀚的体验。</p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发/幂等/数据一致性问题</title>
    <url>/2022/02/27/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1、幂等性"><a href="#1、幂等性" class="headerlink" title="1、幂等性"></a>1、幂等性</h1><p>幂等性是数学上的概念：F(F(x))=F(x)，用在接口上就是：多次重复请求，产生效果一致。</p>
<p>比较典型的场景：支付接口，重复支付会导致多次扣钱；订单接口，同一个订单可能会多次创建。如果没有接口幂等性，则会产生数据一致性问题。</p>
<p>在数据库中，常见操作包括：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>： 天然幂等，重复操作产生效果一致;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span>： 删除也是幂等,删除同一个多次效果一样;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span>： 非幂等操作,每次新增一条;</span><br><span class="line"></span><br><span class="line">UPDATE： a.直接更新某个值的,幂等;</span><br><span class="line">      ： b.更新累加操作的,非幂等;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="2、RestFul规范"><a href="#2、RestFul规范" class="headerlink" title="2、RestFul规范"></a>2、RestFul规范</h1><h3 id="Create-类型的幂等"><a href="#Create-类型的幂等" class="headerlink" title="Create 类型的幂等"></a>Create 类型的幂等</h3><p>创建类型的 API，为了实现幂等性，常见的做法是使用一个 client-side generated deduplication token（客户端生成的唯一ID），在反复重试时使用同一个Token，便于服务端识别重复，如果发现重复，应按创建成功返回。</p>
<h3 id="Update-类型的幂等"><a href="#Update-类型的幂等" class="headerlink" title="Update 类型的幂等"></a>Update 类型的幂等</h3><p>更新类型的 API，通常有唯一ID对需要更新的资源进行标示，以此可以保证幂等。</p>
<p>对于“Delta”语义的操作，有以下几类方式确保幂等性：</p>
<ol>
<li>IncrementBy：基于某个数值增加</li>
<li>SetNewTotal：设置新的总量</li>
<li>使用 Deduplication Token 保证幂等</li>
</ol>
<p>这几种方式各有优缺点，需要根据场景选择合适的方式。</p>
<h3 id="Delete-类型的幂等"><a href="#Delete-类型的幂等" class="headerlink" title="Delete 类型的幂等"></a>Delete 类型的幂等</h3><p>Delete的幂等性问题，往往在于一个对象被删除后，再次试图删除可能会由于数据无法被发现导致出错。这个行为一般来说也没什么问题，虽然严格意义上不幂等，但是也无副作用。</p>
<h3 id="长耗时请求异步化"><a href="#长耗时请求异步化" class="headerlink" title="*** 长耗时请求异步化 ***"></a>*** 长耗时请求异步化 ***</h3><p>如果某个 API 方法需要很长时间才能完成，可以通过：</p>
<ol>
<li>在服务端异步启动任务，并返回 GUID 标示 “长时间运行的操作”资源</li>
<li>客户端通过定时轮询 <em>/polling/{guid}，</em> 获取任务进行的状态。</li>
<li>当任务完成/失败时，客户端可以获取到处理的结果/失败原因。</li>
</ol>
<h1 id="3、Redis分布式锁"><a href="#3、Redis分布式锁" class="headerlink" title="3、Redis分布式锁"></a>3、Redis分布式锁</h1><h2 id="设计方案："><a href="#设计方案：" class="headerlink" title="设计方案："></a><strong>设计方案：</strong></h2><ul>
<li><p>拦截注解 @RedisLock，获取必要的参数</p>
</li>
<li><p>加锁操作</p>
</li>
<li><p>续时操作</p>
</li>
<li><p>结束业务，释放锁</p>
</li>
</ul>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h4 id="（1）业务属性枚举设定"><a href="#（1）业务属性枚举设定" class="headerlink" title="（1）业务属性枚举设定"></a>（1）业务属性枚举设定</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RedisLockTypeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 key 前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ONE(<span class="string">&quot;Business1&quot;</span>, <span class="string">&quot;Test1&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    TWO(<span class="string">&quot;Business2&quot;</span>, <span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    RedisLockTypeEnum(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%s&quot;</span>, <span class="keyword">this</span>.getCode(), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（2）任务队列保存参数"><a href="#（2）任务队列保存参数" class="headerlink" title="（2）任务队列保存参数"></a><strong>（2）任务队列保存参数</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDefinitionHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务唯一 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String businessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁时间 (秒 s)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long lockTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次更新时间（ms）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long lastModifyTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread currentTread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总共尝试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tryCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前尝试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时间周期（毫秒）,公式 = 加锁时间（转成毫秒） / 3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long modifyPeriod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLockDefinitionHolder</span><span class="params">(String businessKey, Long lockTime, Long lastModifyTime, Thread currentTread, <span class="keyword">int</span> tryCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.businessKey = businessKey;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = lockTime;</span><br><span class="line">        <span class="keyword">this</span>.lastModifyTime = lastModifyTime;</span><br><span class="line">        <span class="keyword">this</span>.currentTread = currentTread;</span><br><span class="line">        <span class="keyword">this</span>.tryCount = tryCount;</span><br><span class="line">        <span class="keyword">this</span>.modifyPeriod = lockTime * <span class="number">1000</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（3）设定被拦截的注解名字"><a href="#（3）设定被拦截的注解名字" class="headerlink" title="（3）设定被拦截的注解名字"></a><strong>（3）设定被拦截的注解名字</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLockAnnotation &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特定参数识别，默认取第 0 个下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lockFiled</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tryCount</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义加锁类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RedisLockTypeEnum <span class="title">typeEnum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放时间，秒 s 单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">lockTime</span><span class="params">()</span> <span class="keyword">default</span> 30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）-核心切面拦截的操作"><a href="#（4）-核心切面拦截的操作" class="headerlink" title="（4） 核心切面拦截的操作"></a><strong>（4）</strong> <strong>核心切面拦截的操作</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@annotation</span> 中的路径表示拦截特定注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(cn.sevenyuan.demo.aop.lock.RedisLockAnnotation)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redisLockPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(value = &quot;redisLockPC()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    Method method = resolveMethod(pjp);</span><br><span class="line">    RedisLockAnnotation annotation = method.getAnnotation(RedisLockAnnotation.class);</span><br><span class="line">    RedisLockTypeEnum typeEnum = annotation.typeEnum();</span><br><span class="line">    Object[] params = pjp.getArgs();</span><br><span class="line">    String ukString = params[annotation.lockFiled()].toString();</span><br><span class="line">    <span class="comment">// 省略很多参数校验和判空</span></span><br><span class="line">    String businessKey = typeEnum.getUniqueKey(ukString);</span><br><span class="line">    String uniqueValue = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = redisTemplate.opsForValue().setIfAbsent(businessKey, uniqueValue);</span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You can&#x27;t do it，because another has get the lock =-=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.expire(businessKey, annotation.lockTime(), TimeUnit.SECONDS);</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 将本次 Task 信息加入「延时」队列中</span></span><br><span class="line">        holderList.add(<span class="keyword">new</span> RedisLockDefinitionHolder(businessKey, annotation.lockTime(), System.currentTimeMillis(),</span><br><span class="line">                currentThread, annotation.tryCount()));</span><br><span class="line">        <span class="comment">// 执行业务操作</span></span><br><span class="line">        result = pjp.proceed();</span><br><span class="line">        <span class="comment">// 线程被中断，抛出异常，中断此次请求</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">&quot;You had been interrupted =-=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e ) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Interrupt exception, rollback transaction&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Interrupt exception, please send request again&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;has some error, please check again&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 请求结束后，强制删掉 key，释放锁</span></span><br><span class="line">        redisTemplate.delete(businessKey);</span><br><span class="line">        log.info(<span class="string">&quot;release the lock, businessKey is [&quot;</span> + businessKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="（5）-延时操作"><a href="#（5）-延时操作" class="headerlink" title="（5） 延时操作"></a><strong>（5） 延时操作</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描的任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;RedisLockDefinitionHolder&gt; holderList = <span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池，维护keyAliveTime</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService SCHEDULER = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;redisLock-schedule-pool&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两秒执行一次「续时」操作</span></span><br><span class="line">    SCHEDULER.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里记得加 try-catch，否者报错后定时任务将不会再执行=-=</span></span><br><span class="line">        Iterator&lt;RedisLockDefinitionHolder&gt; iterator = holderList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            RedisLockDefinitionHolder holder = iterator.next();</span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 key 是否还有效，无效的话进行移除</span></span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.opsForValue().get(holder.getBusinessKey()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超时重试次数，超过时给线程设定中断</span></span><br><span class="line">            <span class="keyword">if</span> (holder.getCurrentCount() &gt; holder.getTryCount()) &#123;</span><br><span class="line">                holder.getCurrentTread().interrupt();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否进入最后三分之一时间</span></span><br><span class="line">            <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> shouldExtend = (holder.getLastModifyTime() + holder.getModifyPeriod()) &lt;= curTime;</span><br><span class="line">            <span class="keyword">if</span> (shouldExtend) &#123;</span><br><span class="line">                holder.setLastModifyTime(curTime);</span><br><span class="line">                redisTemplate.expire(holder.getBusinessKey(), holder.getLockTime(), TimeUnit.SECONDS);</span><br><span class="line">                log.info(<span class="string">&quot;businessKey : [&quot;</span> + holder.getBusinessKey() + <span class="string">&quot;], try count : &quot;</span> + holder.getCurrentCount());</span><br><span class="line">                holder.setCurrentCount(holder.getCurrentCount() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4、数据库乐观锁与悲观锁"><a href="#4、数据库乐观锁与悲观锁" class="headerlink" title="4、数据库乐观锁与悲观锁"></a>4、数据库乐观锁与悲观锁</h1><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code> <code>redis分布式锁</code>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong> 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote>
<p>ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
<h1 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h1><p>主要讨论了并发场景读写一致性问题，对于长耗时请求问题，还是不懂怎么解决。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 在线广告概览</title>
    <url>/2022/03/06/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%20(2)/</url>
    <content><![CDATA[<h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1.模型"></a>1.模型</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203061001702.png" alt="image-20220306100052375"></p>
<span id="more"></span>

<h3 id="11-3-1-在线分配问题"><a href="#11-3-1-在线分配问题" class="headerlink" title="11.3.1 在线分配问题"></a>11.3.1 在线分配问题</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203061117646.png" alt="image-20220306111720187"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 定价机制</title>
    <url>/2022/03/20/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%20(3)/</url>
    <content><![CDATA[<p>在进行广告位拍卖时，广告主会不停地试探广告费用下限，从而影响媒体收益。要想理解市场如何达到稳定状态，需要理解三个概念：纳什均衡、广义第二高价、VCG（Vickrey-Clarke-Groves）定价策略。</p>
<h4 id="1-纳什均衡"><a href="#1-纳什均衡" class="headerlink" title="1.纳什均衡"></a>1.纳什均衡</h4><p>即每个广告主都通过出价得到了最符合自己利益的位置。对某一次位置竞价来说，其对称纳什均衡（symmetric Nashequilibrium）状态可以表示为下式：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203202316893.png" alt="image-20220320231605798" style="zoom: 67%;" />

<p>注意这里的下标意义有所调整，这里的 νs 指的是排在 s 位置上的广告的点击价值，并非 s 位置带来的点击价值，而 qs 指的是市场向排在 s 位置上的广告收取的费用，即定价，也就是广告主的单次投入。这一均衡状态的意义很容易理解：对于最终位置排名竞价结果中的每一条广告，其收益都比排在其他位置上要高。显然，在这样的状态下，每个广告主都达到了自己最优的状态，整个系统也就随之稳定下来。</p>
<span id="more"></span>

<h4 id="2-广义第二高价"><a href="#2-广义第二高价" class="headerlink" title="2.广义第二高价"></a>2.广义第二高价</h4><p><strong>第二高价</strong>：指的是在只有一个位置的拍卖中，向赢得该位置的广告主收取其下一位广告主的出价。</p>
<p><strong>广义第二高价</strong>：在搜索广告这种有多个位置的拍卖过程中，对赢得每一个位置的广告主，都按照他下一位的广告位置出价来收取费用。 </p>
<p>实际上，第二高价是单位置拍卖时的最优定价策略，然而广义第二高价却不是多位置拍卖时的最优定价策略（最优策略是下面要介绍的 VCG 定价）。虽然并非理论上最优，广义第二高价却有着实现简单、容易向广告主解释等诸多操作中的优点，因此在实际的竞价广告系统中是<strong>最主流的定价策略</strong>。</p>
<h4 id="3-VCG-定价"><a href="#3-VCG-定价" class="headerlink" title="3.VCG 定价"></a>3.VCG 定价</h4><p>是 Vickrey、Clarke 和 Groves 在研究竞价系统均衡状态时得到的一种理论上较为优越的定价策略。其基本思想是：对于赢得了某个位置的广告主，其所付出的成本应该等于他占据这个位置给其他市场参与者带来的价值损害。在这一原则下，VCG的定价策略可以表示为公式 5.3。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203202325229.png" alt="image-20220320232531146" style="zoom:67%;" />

<p>理论分析表明，VCG 定价策略的优越性体现在如下几个方面：</p>
<p>首先，在这种定价策略的稳定状态下，整个市场是truth-telling的。所谓 truth-telling，可以理解为每个广告主都找到了自己的最优状态。</p>
<p>其次，相对于其他的定价策略，这种定价向广告主收取的费用是最少的。在单广告位拍卖的情形下，VCG定价策略就退化为第二高价策略。</p>
<p>虽然有以上诸多的优点，VCG 定价在竞价广告中却并不是一种主流的方式。这主要是由于：</p>
<ul>
<li><p>逻辑过于复杂，比较难以向广告主解释清楚；</p>
</li>
<li><p>另外在广告主和媒体存在博弈关系的情形下，媒体是否正确地计算了“给其他市场参与者带来的价值损害”也很难验证。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 点击率模型</title>
    <url>/2022/04/03/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%20(4)%20/</url>
    <content><![CDATA[<h3 id="点击率模型的必要性"><a href="#点击率模型的必要性" class="headerlink" title="点击率模型的必要性"></a>点击率模型的必要性</h3><p>不考虑时间、位置等一系列因素，绝对的点击率没有意义。</p>
<p>那能不能再换一个思路，找到一些影响点击率的一些关健因素，对这些因素分别统计？这实际上已经产生了“特征”这样的建模思路了。</p>
<p>比如说，广告位是一个因素，广告本身是一个因素，用户的性别是一个因素，在每个因素上分别统计点击率，从数据充分性上是可行的。</p>
<p>不过这又产生了一个新的问题：我知道了男性用户的平均点击率、广告位S平均点击率、某广告A的平均点击率，那么如何评估某男性用户在广告位S上看到广告A的点击率呢？直觉的方法，是求上面三个点击率的几何平均。不过这里面有一个隐含的假设：<strong>即这三个因素是相互独立的</strong>。然而当特征多起来以后，这样的<strong>独立性假设是很难保证的。</strong></p>
<span id="more"></span>

<h3 id="怎样建立点击率模型"><a href="#怎样建立点击率模型" class="headerlink" title="怎样建立点击率模型"></a>怎样建立点击率模型</h3><p>我们把点击事件 h 看成一个二元取值的随机变量，那么其取值为真（h=1）的概率就是点击率。</p>
<p>因此，点击事件的分布可以写成以点击率 µ为参数的二项分布（binomial distribution）：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204041125269.png" alt="image-20220404112540712" style="zoom:67%;" />

<p> 而点击率预测模型的作用是在（a，u，c）组合与点击的概率µ之间建立函数关系，这可以表示成对µ（a，u，c）=p（h=1|a，u，c）的概率建模问题。</p>
<h4 id="逻辑回归模型-特征工程"><a href="#逻辑回归模型-特征工程" class="headerlink" title="逻辑回归模型+特征工程"></a>逻辑回归模型+特征工程</h4><p>对µ（a，u，c）=p（h=1|a，u，c）的概率建模问题，可以很自然地想到的基础模型是逻辑回归（Logistic Regression，LR）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204041210773.png" alt="image-20220404121004573"></p>
<p>其中 x 表示（a，u，c）组合上的特征矢量，即前面介绍过的受众定向的输出及其派生的其他特征；w 为各特征的加权系数，也就是此模型需要优化的参数；从方法上看，LR是利用线性函数来解决非线性目标，也属于广义线性模型。</p>
<h4 id="FM-GBDT融合"><a href="#FM-GBDT融合" class="headerlink" title="FM+GBDT融合"></a>FM+GBDT融合</h4><p>第一步当然也是基于大规模稀疏特征LR。</p>
<p>第二步，为了更好的刻画长尾，自动发现组合特征，采用了FM。在同样的训练时间下，AUC提升，模型泛化性能可控。</p>
<p>第三步：为了更好的fine tuning头部和提升时效性，采用了用gbdt加动态特征的模型。最后呢，把这两个模型简单的做线性融合，由于俩个模型的特征和模型差异性较大，融合后auc也有显著的提升。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 计算广告基础</title>
    <url>/2022/03/06/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h3 id="1-广告有效性模型"><a href="#1-广告有效性模型" class="headerlink" title="1.广告有效性模型"></a>1.广告有效性模型</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271103448.png" alt="image-20220227110314006"></p>
<span id="more"></span>

<p><strong>曝光</strong>：主要取决于广告位</p>
<p><strong>关注</strong>：不要干扰打断用户行为、符合用户兴趣和需求</p>
<p><strong>理解</strong>：在用户能理解的具体兴趣范围内</p>
<p><strong>接受</strong>：表达信息恰当</p>
<p><strong>保持</strong>：创意设计</p>
<p><strong>决策</strong>：具体的广告策略或技术</p>
<h3 id="2-计算广告核心挑战"><a href="#2-计算广告核心挑战" class="headerlink" title="2.计算广告核心挑战"></a>2.计算广告核心挑战</h3><ul>
<li><p>计算广告的核心问题，是为一系列用户与环境的组合找到最合适的广告投放策略以优化整体广告活动的利润。</p>
</li>
<li><p>优化问题描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271111882.png" alt="image-20220227111138694"></p>
<p>表达式中的 a、u、c 三个变量，分别代表广告、用户与环境。</p>
</li>
</ul>
<h3 id="3-广告收入分解"><a href="#3-广告收入分解" class="headerlink" title="3.广告收入分解"></a>3.广告收入分解</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271119335.png" alt="image-20220227111957205"></p>
<p>广告点击与广告展现的比率称为 <strong>点击率（Click Through Rate，CTR）</strong>；</p>
<p>点击行为成功以后，将会打开广告主的 <strong>落地页（landing page）</strong>；</p>
<p>落地页成功打开次数与点击次数的比例称为 <strong>到达率</strong>；</p>
<p>如果用户从落地页开始，进一步完成下单等操作，则称为 <strong>转化</strong>；</p>
<p>转化次数与到达次数的比例称为 <strong>转化率（Conversion Rate，CVR）</strong>；</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271121325.png" alt="image-20220227112106244"></p>
<p>用 <strong>µ</strong> 表示点击率，用 <strong>ν</strong> 表示点击价值（clickvalue），即单次点击为广告产品带来的收益。而这两部分的乘积定量地表示了某次或若干次展示的期望 CPM 值，就是前面提到的 eCPM[4]。</p>
<p>在对多个检索候选进行排序时，是根据 <strong>eCPM</strong> 还是<strong>CTR排序</strong>也是区别广告产品和用户产品的重要策略特征。</p>
<h3 id="4-结算方式"><a href="#4-结算方式" class="headerlink" title="4.结算方式"></a>4.结算方式</h3><p>表 2-1 展示了以上几种结算方式概要的对比。综合来看可以认为，对于效果广告，CPC计费方式最有利于发挥供给方和需求方的长处，因而在市场上被广泛接受；对于品牌广告，由于效果和目的有时不便于直接衡量，可以考虑按照 CPM 的方式计费；而CPS 的计费方式只在一些特定的环境下才比较合理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271125174.png" alt="image-20220227112520031"></p>
<p>在 CPC 或 CPS 结算的广告交易中，由于计费的指标，即点击或转化在广告主的网站上产生，所以并不需要特别的监测服务。因此，可以认为广告监测主要服务的对象是品牌广告主。随着 CPM 广告定向方式越来越复杂，广告监测也从简单的展示和点击记数到频次、人口属性等信息的验证和计量。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件</title>
    <url>/2022/01/18/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h3 id="主要使用到的技术包括："><a href="#主要使用到的技术包括：" class="headerlink" title="主要使用到的技术包括："></a>主要使用到的技术包括：</h3><h4 id="springboot-spring-cloud-mybatis-redis-ehcache-rabbit-mq-AWS-S3-mysql"><a href="#springboot-spring-cloud-mybatis-redis-ehcache-rabbit-mq-AWS-S3-mysql" class="headerlink" title="springboot + spring cloud + mybatis + redis + ehcache + rabbit mq + AWS S3 + mysql"></a>springboot + spring cloud + mybatis + redis + ehcache + rabbit mq + AWS S3 + mysql</h4><h3 id="ehcache"><a href="#ehcache" class="headerlink" title="ehcache"></a><strong>ehcache</strong></h3><p>EhCache直接在JVM中进行缓存，速度快，效率高。与Redis相比，操作简单、易用、高效，虽然EhCache也提供有缓存共享的方案，但对分布式集群的支持不太好，缓存共享实现麻烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value &#x3D; &quot;serviceNameCache&quot;, key &#x3D; &quot;targetClass+methodName+#p0&quot;)</span><br><span class="line">@CachePut 用于新增</span><br><span class="line">@CacheEvict 用于删除</span><br><span class="line">@Caching 用于组合条件</span><br></pre></td></tr></table></figure>



<h3 id="redis-缓存、分布式锁、事务、持久化存储"><a href="#redis-缓存、分布式锁、事务、持久化存储" class="headerlink" title="redis:缓存、分布式锁、事务、持久化存储"></a>redis:缓存、分布式锁、事务、持久化存储</h3><p>redis单线程为什么这么快 ？</p>
<p>redis 常见数据结构以及使用场景分析 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. String：key-value类型 常规key-value缓存应用； 常规计数：微博数，粉丝数等。 </span><br><span class="line"></span><br><span class="line">2. Hash 是一个 string 类型的 field 和 value 的映射表。</span><br><span class="line">   hash 特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值。</span><br><span class="line">   比如存储用户信息，商品信息等等</span><br><span class="line"></span><br><span class="line">3. List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作</span><br><span class="line">   微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。</span><br><span class="line"></span><br><span class="line">4. Set 是可以自动排重的。</span><br><span class="line">   Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</span><br><span class="line"></span><br><span class="line">5. Sorted Set 增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 </span><br><span class="line">   举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜</span><br></pre></td></tr></table></figure>

<p>删除机制</p>
<p>哨兵机制</p>
<p>缓存穿透 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量</span><br><span class="line">请求而崩掉。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</span><br><span class="line">另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</span><br></pre></td></tr></table></figure>

<p>缓存雪崩 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决办法：</span><br><span class="line"></span><br><span class="line">事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 </span><br><span class="line"></span><br><span class="line">事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 </span><br><span class="line"></span><br><span class="line">事后：利用 redis 持久化机制保存的数据尽快恢复缓存</span><br></pre></td></tr></table></figure>



<p>extends WebSecurityConfigurerAdapter</p>
<p>implements Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Group group;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    <span class="keyword">private</span> Long creatorId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(baseUrls, <span class="number">0</span>, urls, excludeUrls.size(), baseUrls.length);</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(urls).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/api/admin/users&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录和权限校验失败处理</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint((request, response, authException)</span><br><span class="line">                -&gt; &#123;</span><br><span class="line">                Map&lt;String, String&gt; message = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">                message.put(<span class="string">&quot;message&quot;</span>, I18nContext.getMessage(<span class="string">&quot;AUTH_ERROR_403&quot;</span>));</span><br><span class="line">                message.put(<span class="string">&quot;url&quot;</span>, ContextConfig.getConf(<span class="string">&quot;WEB_OAUTH_LOGIN_URL&quot;</span>));</span><br><span class="line">                response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">                MessageUtils.respMsg(response, message);</span><br><span class="line">            &#125;)</span><br><span class="line">            .accessDeniedHandler((request, response, accessDeniedException)</span><br><span class="line">                -&gt; MessageUtils.respStringMsg(HttpStatus.FORBIDDEN));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add filter</span></span><br><span class="line">        http.addFilterBefore(<span class="keyword">new</span> OauthLoginFilter(sysUserService),</span><br><span class="line">            UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="rabbit-mq"><a href="#rabbit-mq" class="headerlink" title="rabbit-mq"></a>rabbit-mq</h3><p>模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Direct exchange:routingkey完全匹配</span><br><span class="line">Fanout exchange：订阅模式，exchange绑定的所有队列</span><br><span class="line">Topic exchange：routingkey通配</span><br><span class="line">Headers exchange：不通过routingkey,通过请求头信息</span><br></pre></td></tr></table></figure>



<p>死信队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。</span><br><span class="line"></span><br><span class="line">消息变成死信，可能是由于以下的原因：</span><br><span class="line"></span><br><span class="line">- 消息被拒绝</span><br><span class="line">- 消息过期</span><br><span class="line">- 队列达到最大长度</span><br><span class="line"></span><br><span class="line">DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogOperation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operation</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哪些字段需要被操作日志锁记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] fields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哪些字段需要联合判断，如时间字段:begin-end</span></span><br><span class="line"><span class="comment">     * 当其中一个字段发生变化即认为两者都发生变化。</span></span><br><span class="line"><span class="comment">     * 说明:unionFields中字段不要在fields中存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String [] unionFields() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作日志中的操作（） 中的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operationField</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作者,SpEL表达式，默认从权限工具类获取。</span></span><br><span class="line"><span class="comment">     * hoa-log 可以不用依赖hoa-security模块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operator</span><span class="params">()</span> <span class="keyword">default</span> &quot;@userServiceImpl.<span class="title">getCurrentUser</span><span class="params">()</span>.<span class="title">getId</span><span class="params">()</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作前的值,使用 SPEL 表达式，参考如下：</span></span><br><span class="line"><span class="comment">     * #this.getDao().findOne(#p0.id)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">originExpression</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作后的值，使用 SPEL 表达式，参考如下：</span></span><br><span class="line"><span class="comment">     * #p0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">currentExpression</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 SPEL 表达式判断在什么情况下记录本次的操作日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">true</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;app.monitor.task.day&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;SERVICENAME_SUBSCRIPTION_DAY&quot;, lockAtLeastFor = 30000, lockAtMostFor = 60000)</span></span><br></pre></td></tr></table></figure>



<h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><h3 id="openfeign"><a href="#openfeign" class="headerlink" title="openfeign"></a>openfeign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@FeignClient</span>:</span></span><br><span class="line"><span class="comment"> *  name/value属性: 这两个的作用是一样的,指定的是调用服务的微服务名称</span></span><br><span class="line"><span class="comment"> *  url : 指定调用服务的全路径,经常用于本地测试</span></span><br><span class="line"><span class="comment"> *  如果同时指定name和url属性: 则以url属性为准,name属性指定的值便当做客户端的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;$&#123;openfeign.serviceName.accountClient&#125;&quot;, url = &quot;$&#123;openfeign.serviceName.accountDomain&#125;&quot;,</span></span><br><span class="line"><span class="meta">        fallbackFactory = FeignHacBackService.class, configuration = FeignConfiguration.class)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignHacService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;$&#123;openfeign.serviceName.userApi&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">HacMessage&lt;HacUser&gt; <span class="title">syncUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">             </span><br></pre></td></tr></table></figure>

<h3 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h3>]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基础语法</title>
    <url>/2022/01/19/java%E5%85%AB%E8%82%A1%E6%96%87-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-面向对象包括哪些特性，如何理解？"><a href="#1-面向对象包括哪些特性，如何理解？" class="headerlink" title="1.面向对象包括哪些特性，如何理解？"></a>1.面向对象包括哪些特性，如何理解？</h3><ul>
<li><p>封装。通过private关键字，将对象的属性和方法封装起来。隐藏一切可隐藏的东西，只对外界提供最简单的编程接口，同时保护了数据。</p>
</li>
<li><p>继承。父类引用指向子类对象，Animal animal = new Cat( ) 即声明的是父类，实际指向的是子类的一个对象。 继承是为了重用父类代码，子类继承父类就拥有了父类的成员。</p>
</li>
<li><p>多态。同一个行为具有不同的表现形式。实现多态需要做两件事：</p>
<p>第一：方法重写（子类继承父类并重写父类中已有的或抽象的方法）</p>
<p>第二：对象造型（用父类引用指向子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<span id="more"></span></li>
</ul>
<h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><p><strong>重载</strong> : 发生在同一个类中。方法名一样，方法参数类型、个数、顺序不一样。返回值类型和访问权限可以不一致。</p>
<p><strong>重写</strong> ：发生在父子类中，子类重写父类方法。方法名一样，方法返回值小于等于父类，方法访问权限大于等于父类。当父类中方法使用private修饰时，子类不能重写父类中的方法。</p>
<h3 id="3-String、StringBuffer、StingBuilder的区别"><a href="#3-String、StringBuffer、StingBuilder的区别" class="headerlink" title="3.String、StringBuffer、StingBuilder的区别"></a>3.String、StringBuffer、StingBuilder的区别</h3><ul>
<li><p><strong>可变性</strong></p>
<p>String类中使用final关键字字符数组保存字符串，所以String是不可变字符串。</p>
<p>StringBuilder和StringBuffer都继承自AbstractStringBuilder，因此两者都是可变字符串</p>
</li>
<li><p><strong>线程安全性</strong></p>
<p>String可以理解为字符串常量，因此是线程安全的。</p>
<p>StringBuffer对方法或者调用的方法加了同步锁，因此也是线程安全的。</p>
<p>StringBuilder并没有对方法加同步锁，所以是非线程安全的。</p>
</li>
<li><p><strong>性能</strong></p>
<p>String每次都会创建一个新的对象，并将指针指向这个新对象。</p>
<p>StringBuffer每次都是对对象本身进行操作，相同情况下，StringBuilder比StringBuffer的性能提升10%-15%，却要承担线程不安全的风险</p>
</li>
<li><p>使用总结：</p>
<p>对字符串进行少量修改：使用String</p>
<p>多线程操作字符串缓冲区下操作大量数据：StringBuffer</p>
<p>单线程操作字符串缓冲区下操作大量数据：StringBuilder</p>
</li>
</ul>
<h3 id="4-自动装箱与自动拆箱"><a href="#4-自动装箱与自动拆箱" class="headerlink" title="4.自动装箱与自动拆箱"></a>4.自动装箱与自动拆箱</h3><p>自动装箱：将基本数据类型用他们对应的包装数据类型包装起来</p>
<p>自动拆箱：将包装数据类型转化为基本数据类型</p>
<blockquote>
<p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
</blockquote>
<h3 id="5-关于final关键字的总结"><a href="#5-关于final关键字的总结" class="headerlink" title="5.关于final关键字的总结"></a>5.关于final关键字的总结</h3><p>final关键字主要用在三个地方：类、方法、变量。</p>
<ul>
<li>当final修饰变量时，一旦变量被初始化，就不可以被随意更改。</li>
<li>当final修饰方法时，这个方法不可以被覆盖重写。</li>
<li>当final修饰类时，该类不可以被继承，类中的方法被隐式地申明为final方法。</li>
</ul>
<p>使用final类的好处如下：第一是把方法锁住，防止继承类修改它的含义；第二是提升性能，在早期的Java版本中，final方法会转化为嵌入方法，不过现在的Java版本已经不靠final来提升方法性能了。</p>
<h3 id="6-Object类的常用方法总结"><a href="#6-Object类的常用方法总结" class="headerlink" title="6.Object类的常用方法总结"></a>6.Object类的常用方法总结</h3><p>Object类是一个特殊的类，它是所有类的父类，主要提供了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- toString() </span><br><span class="line">    </span><br><span class="line">- hashCode()</span><br><span class="line">    </span><br><span class="line">- getClass() <span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line">    </span><br><span class="line">- equals() <span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line">    </span><br><span class="line">- clone() <span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass()== x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line">    </span><br><span class="line">- notify() <span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"></span><br><span class="line">- notifyAll() <span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"></span><br><span class="line">- wait() <span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"></span><br><span class="line">- finalize() <span class="comment">//实例被垃圾回收器回收的时候触发的操作     </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-Java中的异常处理"><a href="#7-Java中的异常处理" class="headerlink" title="7.Java中的异常处理"></a>7.Java中的异常处理</h3><h4 id="7-1-异常分类"><a href="#7-1-异常分类" class="headerlink" title="7.1 异常分类"></a>7.1 异常分类</h4><p>在Java中所有的异常都有一个共同的父类<strong>Throwable</strong>类，Throwable类有两个重要的子类：**Error **和 <strong>Exception</strong>。</p>
<p>Error是程序无法处理的异常，Exception是程序可以处理的异常。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203192311254.png" alt="image-20220319231142003"></p>
<h4 id="7-2-异常处理"><a href="#7-2-异常处理" class="headerlink" title="7.2 异常处理"></a>7.2 异常处理</h4><p>处理方式：</p>
<ol>
<li>不处理，直接抛出异常</li>
<li>使用 try catch 捕获处理异常</li>
</ol>
<h4 id="7-3-throw-throws区别"><a href="#7-3-throw-throws区别" class="headerlink" title="7.3 throw throws区别"></a>7.3 throw throws区别</h4><h5 id="位置不同："><a href="#位置不同：" class="headerlink" title="位置不同："></a>位置不同：</h5><p>throws: 使用在函数上，后面跟的是异常类，可以跟多个</p>
<p>throw: 使用用在方法内，后面跟的是异常对象，只能跟一个</p>
<h5 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h5><p>throws: 申明可能抛出的异常，不一定发生，可以进行预处理</p>
<p>throw: 功能执行到此结束，将具体异常对象抛给调用者</p>
<h3 id="8-接口和抽象类的区别是什么"><a href="#8-接口和抽象类的区别是什么" class="headerlink" title="8.接口和抽象类的区别是什么"></a>8.接口和抽象类的区别是什么</h3><ol>
<li><p>接口类的变量必须是final类型，抽象类不一定</p>
</li>
<li><p>接口类的方法默认加了public abstract JDK1.8之后接口类可以具有默认的实现方法</p>
<p>抽象类中可以有非抽象的方法</p>
</li>
<li><p>子类可以继承一个或多个接口，却只能继承一个抽象方法</p>
</li>
<li><p>继承了接口的子类必须实现接口的所有抽象方法，继承了抽象类的子类可以不完全实现，但是不完全实现的子类也会自动转换为抽象类</p>
</li>
</ol>
<h3 id="9-反射"><a href="#9-反射" class="headerlink" title="9.反射"></a>9.反射</h3><p>在 Java 中的反射机制是指<strong>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法</strong>；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="9-1-编译时类型和运行时类型"><a href="#9-1-编译时类型和运行时类型" class="headerlink" title="9.1 编译时类型和运行时类型"></a>9.1 编译时类型和运行时类型</h4><blockquote>
<p> Person p = new Student （）；</p>
</blockquote>
<p>编译时类型为Person，运行时类型为Student，当程序需要获取运行时的对象属性和方法时，需要用到反射机制</p>
<h4 id="9-2-反射API"><a href="#9-2-反射API" class="headerlink" title="9.2 反射API"></a>9.2 反射API</h4><p>class 类：反射的核心类，用来获取对象的属性和方法等</p>
<p>field 类：反射的基本类，用来表示对象的变量，可以用来获取和修改属性值</p>
<p>method 类：反射的基本类，用来获取对象的方法</p>
<p> constructor 类：java . lang . reflect 类中方法，表示类的构造方法</p>
<h4 id="9-3-获取对象的三种方法"><a href="#9-3-获取对象的三种方法" class="headerlink" title="9.3 获取对象的三种方法"></a>9.3 获取对象的三种方法</h4><p><strong>调用某个对象的 getClass() 方法</strong></p>
<blockquote>
<p>Person p = new Person();</p>
<p>Class clazz = p.getClass();</p>
</blockquote>
<p><strong>调用某个类的 class 属性</strong></p>
<blockquote>
<p>Class clazz = Person.Class;</p>
</blockquote>
<p><strong>使用forName()方法</strong></p>
<blockquote>
<p>Class clazz = Class.forName(“类的全限定名称”);  //最常用的方法</p>
</blockquote>
<h4 id="9-4-操作反射相关的API"><a href="#9-4-操作反射相关的API" class="headerlink" title="9.4 操作反射相关的API"></a>9.4 操作反射相关的API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Person 类的 Class 对象</span></span><br><span class="line"> Class clazz=Class.forName(<span class="string">&quot;reflection.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有方法信息</span></span><br><span class="line"> Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取 Person 类的所有成员属性信息</span></span><br><span class="line"> Field[] field=clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有构造方法信息</span></span><br><span class="line"> Constructor[] constructor=clazz.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>



<h3 id="10-注解"><a href="#10-注解" class="headerlink" title="10.注解"></a>10.注解</h3><p><strong>Annatation</strong>(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p>
<p><strong>@Target 修饰的对象范围</strong> </p>
<p>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、 接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数 和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰 其修饰的目标 </p>
<p><strong>@Retention 定义 被保留的时间长短</strong> </p>
<p>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描 述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：  SOURCE:在源文件中有效（即源文件保留）  CLASS:在 class 文件中有效（即 class 保留）  RUNTIME:在运行时有效（即运行时保留） </p>
<p><strong>@Documented 描述-javadoc</strong></p>
<p><strong>@ Documented 用于描述其它类型的 annotation</strong> 应该被作为被标注的程序成员的公共 API，</p>
<h3 id="11-浅拷贝与深拷贝"><a href="#11-浅拷贝与深拷贝" class="headerlink" title="11.浅拷贝与深拷贝"></a>11.浅拷贝与深拷贝</h3><p><strong>浅拷贝</strong>：对基本数据类型进行<strong>值传递</strong>，对引用数据类型进行<strong>引用传递</strong></p>
<p><strong>深拷贝</strong>：对基本数据类型进行<strong>值传递</strong>，对引用数据类型，创建一个新的对象，并复制其内容</p>
<p>对 clone() 方法，只能对当前对象进行浅拷贝，引用类型依然是在传递引用。</p>
<p>那么，如何进行一个深拷贝呢？</p>
<p>比较常用的方案有两种：</p>
<ol>
<li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li>
<li>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。</li>
</ol>
<h2 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h2><h3 id="1-List集合"><a href="#1-List集合" class="headerlink" title="1.List集合"></a><strong>1.List集合</strong></h3><p> <strong>ArrayList ：</strong> 数据结构底层是 Object 数组。扩容时，需要将已有数组的数据复制到新的存储空间中。适合随机查找和遍历，不适合插入和删除。</p>
<p><strong>Vector ：</strong> 数据结构底层是 Object 数组。支持线程的同步。<font color = #bbbb>即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，</font>但实现同步需要很高的花费，因此， 访问它比访问 ArrayList 慢。</p>
<p><strong>LinkedList ：</strong>数据结构底层是双向链表。很适合数据的动态插入和删除，随机访问和遍历速度比较 慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆、栈、队列和双向队列使用。</p>
<h3 id="2-Set集合"><a href="#2-Set集合" class="headerlink" title="2.Set集合"></a>2.Set集合</h3><p><strong>HashSet ：</strong> <font color=#bbbb>存储元素的顺序并不是按照存入时的顺序（和 List 显然不 同）</font> 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法。</p>
<p><strong>TreeSet：</strong> </p>
<ol>
<li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增 加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p>
</li>
<li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，<font color=#bbbb>自定义的类必须实现 Comparable 接口，并且重写相应的 compareTo()函数，</font>才可以正常使 用。 </p>
</li>
<li><p> 在覆写 compareTo()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整 数、零或正整数。</p>
</li>
</ol>
<p><strong>LinkedHashSet：</strong> 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并 通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操 作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可</p>
<h3 id="3-Map集合"><a href="#3-Map集合" class="headerlink" title="3.Map集合"></a><strong>3.Map集合</strong></h3><h4 id="1-HashMap-和-Hashtable-的区别"><a href="#1-HashMap-和-Hashtable-的区别" class="headerlink" title="1. HashMap 和 Hashtable 的区别"></a>1. HashMap 和 Hashtable 的区别</h4><ol>
<li><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（要保证线程安全的话就使用 ConcurrentHashMap 吧！）； </p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在 代码中使用它； </p>
</li>
<li><p><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键 所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。 </p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<p> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来 的2倍。</p>
<p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充 为2的幂次方大小。也就是说 HashMap 总 是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</p>
</li>
<li><p> <strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ol>
<h4 id="2-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.ConcurrentHashMap 和 Hashtable 的区别"></a>2.ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 </p>
<ul>
<li><p><strong>底层数据结构：</strong>ConcurrentHashMap 数组+链表/红黑二叉树。Hashtable 采用 数组+链表 的形式</p>
</li>
<li><p><strong>实现线程安全的方式（重要）：</strong></p>
<p>① ConcurrentHashMap 使用 Node 数组+链表+红黑 树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。</p>
<p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全， 效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
<h4 id="3-Map数据结构总结"><a href="#3-Map数据结构总结" class="headerlink" title="3.Map数据结构总结"></a>3.Map数据结构总结</h4><p><strong>HashMap：</strong>数组+链表/红黑树，</p>
<p><strong>LinkedHashMap:</strong>  继承自 HashMap，数组+链表/红黑树。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<p><strong>HashTable:</strong> 数组+链表组成的，</p>
<p><strong>TreeMap:</strong> 红黑树（自平衡的排序二叉树）</p>
<h4 id="4-HashMap扩容机制"><a href="#4-HashMap扩容机制" class="headerlink" title="4.HashMap扩容机制"></a>4.HashMap扩容机制</h4><p><strong>当前存放新值（<em>注意不是替换已有元素位置时</em>）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</strong></p>
<p>　　注：</p>
<p>　　（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,”zhangsan”），而map里面原有数据&lt;”name”,”lisi”&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</p>
<p>　　（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</p>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><h3 id="1-多线程的创建方式"><a href="#1-多线程的创建方式" class="headerlink" title="1.多线程的创建方式"></a>1.多线程的创建方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><ol>
<li><p>定义子类继承Thread类。</p>
</li>
<li><p>子类中重写Thread类中的run方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建Thread子类对象，即创建了线程对象。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mt.start();</span><br></pre></td></tr></table></figure>

<p> 注意点：</p>
<ol>
<li> 如果自己<strong>手动调</strong>用run()方法，那么就只是<strong>普通方法，没有启动多线程模式</strong>。</li>
<li>  run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定</li>
<li> 想要启动多线程，必须调用start方法。 </li>
<li> 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”。</li>
</ol>
<h4 id="实现-runnable-、callable-接口"><a href="#实现-runnable-、callable-接口" class="headerlink" title="实现 runnable 、callable 接口"></a>实现 runnable 、callable 接口</h4><ol>
<li><p>定义子类，实现Runnable接口。</p>
</li>
<li><p>子类中重写Runnable接口中的run方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>通过Thread类含参构造器创建线程对象。</strong> </p>
</li>
<li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 </p>
</li>
<li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestRunnable test = <span class="keyword">new</span> TestRunnable();</span><br><span class="line"><span class="comment">//含参构造器,开启线程</span></span><br><span class="line">Thread(test.<span class="string">&quot;threadName&quot;</span>).start();</span><br></pre></td></tr></table></figure>



<h5 id="-通过实现方式创建线程的好处"><a href="#-通过实现方式创建线程的好处" class="headerlink" title="** 通过实现方式创建线程的好处 **"></a>** 通过实现方式创建线程的好处 **</h5><p>​        避免了单继承的局限性 </p>
<p>​        多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。</p>
<h5 id="-runnable和callable的区别"><a href="#-runnable和callable的区别" class="headerlink" title="** runnable和callable的区别 **"></a>** runnable和callable的区别 **</h5><p>与使用Runnable相比， Callable功能更强大些 </p>
<ul>
<li><p>相比run()方法，可以借助FutureTask类，比如获取返回结果</p>
</li>
<li><p>方法可以抛出异常 </p>
</li>
<li><p>支持泛型的返回值 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过实现callable创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建callable对象</span></span><br><span class="line">        Callable&lt;String&gt; myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 2.由上面的callable对象创建一个FutureTask对象</span></span><br><span class="line">        FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(myCallable);</span><br><span class="line">        <span class="comment">// 3.由FutureTask创建一个Thread对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">        <span class="comment">// 4.开启线程</span></span><br><span class="line">        t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p> 背景：<strong>经常创建和销毁、使用</strong>量特别大的资源，比如并发情况下的线程， <strong>对性能影响很大</strong>。 </p>
<p> 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p>
<p> 好处： </p>
<p>​         提高响应速度（减少了创建新线程的时间） </p>
<p>​         降低资源消耗（重复利用线程池中线程，不需要每次都创建） </p>
<p>​         便于线程管理 ，参数如下：</p>
<p>​                 corePoolSize：核心池的大小 </p>
<p>​                 maximumPoolSize：最大线程数 </p>
<p>​                 keepAliveTime：线程没有任务时最多保持多长时间后会终止</p>
<h3 id="2-线程池的创建方式"><a href="#2-线程池的创建方式" class="headerlink" title="2.线程池的创建方式"></a>2.线程池的创建方式</h3><p>java中提供了线程池创建的<strong>顶级接口：ExcutorService</strong>。ThreadPoolExcutor实现了ExcutorService，Excutors创建线程池返回一个ExcutorService对象。</p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<blockquote>
<p>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>说明：Executors 返回的线程池对象的弊端如下：</p>
<p>1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>
<p>2）CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
</blockquote>
<h5 id="-通过-ThreadPoolExcutor-创建"><a href="#-通过-ThreadPoolExcutor-创建" class="headerlink" title=" 通过 ThreadPoolExcutor 创建"></a><strong> 通过 ThreadPoolExcutor 创建</strong></h5><p>​    最原始的创建线程池的方式，它包含了 7 个参数可供设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数，线程池中始终存活的线程数。</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//最大线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//最大线程存活时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列，用来存储线程池等待执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂，主要用来创建线程，默认为正常优先级、非守护线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，拒绝处理任务时的策略，系统提供了 <span class="number">4</span> 种可选</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myThreadPoolExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, 													TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(index + <span class="string">&quot; 被执行,线程名:&quot;</span> + 						 											Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="-通过-Excutors-创建"><a href="#-通过-Excutors-创建" class="headerlink" title=" 通过 Excutors 创建"></a><strong> 通过 Excutors 创建</strong></h5><ol>
<li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</li>
<li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</li>
<li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</li>
<li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；</li>
<li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；</li>
<li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）</li>
</ol>
<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 2 个数据级的线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务被执行,线程:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池执行任务(一次添加 4 个任务)</span></span><br><span class="line">    <span class="comment">// 执行任务的方法有两种:submit 和 execute</span></span><br><span class="line">    threadPool.submit(runnable);  <span class="comment">// 执行方式 1:submit</span></span><br><span class="line">    threadPool.execute(runnable); <span class="comment">// 执行方式 2:execute</span></span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="3-线程的分类"><a href="#3-线程的分类" class="headerlink" title="3.线程的分类"></a>3.线程的分类</h3><p>java中的线程分为两类，一个是<strong>守护线程</strong>，一个是<strong>用户线程</strong>。</p>
<ul>
<li>守护线程是用来服务用户线程的，通过在调用start()前，设置**thread.setDaemon(true)**，可以将用户线程转化为守护线程</li>
<li>java的垃圾回收线程就是一个典型的守护线程。</li>
<li>若jvm中都是守护线程，则当前jvm将退出。</li>
</ul>
<h3 id="4-Thread类相关的方法"><a href="#4-Thread类相关的方法" class="headerlink" title="4.Thread类相关的方法"></a>4.Thread类相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程让步</span></span><br><span class="line"><span class="comment">//    暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</span></span><br><span class="line"><span class="comment">//    若队列中没有同优先级的线程，忽略此方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当某个程序执行调用其他线程的join方法时，调用线程将阻塞,直至被调用线程执行完毕</span></span><br><span class="line"><span class="comment">//    优先级较低的线程也可以获得执行</span></span><br><span class="line">join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程休眠，执行其他线程，到达设定时间后，线程重新排队执行</span></span><br><span class="line"><span class="comment">//    抛出InterruptedException异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否还活着</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制结束线程，不推荐使用</span></span><br><span class="line">stop();</span><br></pre></td></tr></table></figure>



<h3 id="5-线程的调度"><a href="#5-线程的调度" class="headerlink" title="5.线程的调度"></a>5.线程的调度</h3><ul>
<li>相同优先级的线程组成先进先出队列，使用<strong>时间片</strong>的调度策略；</li>
<li>不同优先级的线程使用优先调度的<strong>抢占式</strong>策略（高优先级的线程抢占CPU）；</li>
</ul>
<h3 id="6-线程的生命周期"><a href="#6-线程的生命周期" class="headerlink" title="6.线程的生命周期"></a>6.线程的生命周期</h3><p>创建 —&gt; 就绪 —&gt; 运行 —&gt; 阻塞 —&gt; 死亡</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204071333072.png" alt="image-20220407133326412"></p>
<h3 id="7-线程的同步"><a href="#7-线程的同步" class="headerlink" title="7.线程的同步"></a>7.线程的同步</h3><p>同步机制：在《Thinking In Java》中说，对于并发任务，我们需要某种方式来防止两个任务访问共享资源。防止这种冲突的方法就是，在某个任务访问资源时，为其加上锁，直至任务完成。 当资源被解锁时，其他任务才能访问这个资源。</p>
<h4 id="synchronized-同步锁"><a href="#synchronized-同步锁" class="headerlink" title="synchronized 同步锁"></a>synchronized 同步锁</h4><p>首先，我们需要清楚两个概念：</p>
<blockquote>
<p>类锁：所有对象实例共用一个锁</p>
<p>对象锁：一个对象一个锁，多个对象多个锁</p>
</blockquote>
<ul>
<li>任何对象都可以作为锁的对象。所有对象都具有唯一的锁（监视器）</li>
<li>当 Synchronized 修饰静态方法时，锁住的是类对象。</li>
<li>当 Synchronized 修饰实例方法时，锁住的是实例对象。</li>
<li>当 Synchronized 修饰代码块时，可以锁住指定对象。</li>
</ul>
<h4 id="ReentrantLock同步锁"><a href="#ReentrantLock同步锁" class="headerlink" title="ReentrantLock同步锁"></a>ReentrantLock同步锁</h4><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完 成 synchronized 所能完成的所有工作外，还提供了诸如<font color=#bbbb> 可响应中断锁、可轮询锁请求、定时锁等 避免多线程死锁</font>的方法。</p>
<h5 id="ReetrantLock实现"><a href="#ReetrantLock实现" class="headerlink" title="ReetrantLock实现"></a>ReetrantLock实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="comment">// Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line">	<span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 				lock.lock();<span class="comment">// lock 加锁</span></span><br><span class="line">            </span><br><span class="line">				<span class="comment">// 1：通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"> 				condition.await();</span><br><span class="line">				<span class="comment">// 2：signal 方法唤醒</span></span><br><span class="line">				condition.signal();</span><br><span class="line"> 			</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 				e.printStackTrace();</span><br><span class="line"> 		&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> 				lock.unlock();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a>Condition 类和 Object 类锁方法区别区别</h5><ol>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</li>
</ol>
<h4 id="比较ReentrantLock-与-synchronized"><a href="#比较ReentrantLock-与-synchronized" class="headerlink" title="比较ReentrantLock 与 synchronized"></a>比较ReentrantLock 与 synchronized</h4><ol>
<li>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，<font color=#bbbb>ReentrantLock 加锁后需要手动进行解锁</font>。为了避免程序出 现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</li>
<li>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。 </li>
<li>ReenTrantLock增加了一些高级功能。主要来说主要有三点：<font color=#bbbb>①等待可中断；②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件）</font></li>
<li>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</li>
</ol>
<h3 id="8-线程间的通信"><a href="#8-线程间的通信" class="headerlink" title="8.线程间的通信"></a>8.线程间的通信</h3><h4 id="wait-、notify-和notifyAll-的区别"><a href="#wait-、notify-和notifyAll-的区别" class="headerlink" title="wait() 、notify() 和notifyAll() 的区别"></a>wait() 、notify() 和notifyAll() 的区别</h4><p> wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。 </p>
<p> notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 </p>
<p> notifyAll ()：唤醒正在排队等待资源的所有线程结束等待. </p>
<p> <strong>这三个方法只有在synchronized方法或synchronized代码块中才能使用</strong>，否则会报 java.lang.IllegalMonitorStateException异常。 </p>
<p> 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。</p>
<h4 id="小练习：银行取钱问题"><a href="#小练习：银行取钱问题" class="headerlink" title="小练习：银行取钱问题"></a>小练习：银行取钱问题</h4><p>1.定义一个Account类 </p>
<p>​        1）该Account类封装了账户编号（String）和余额（double）两个属性 </p>
<p>​        2）设置相应属性的getter和setter方法 </p>
<p>​        3）提供无参和有两个参数的构造器 </p>
<p>​        4）系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写 </p>
<p>2.提供两个取钱的线程类：小明、小明’s wife </p>
<p>​        1）提供了Account类的account属性和double类的取款额的属性 </p>
<p>​        2）提供带线程名的构造器 </p>
<p>​        3）run()方法中提供取钱的操作 </p>
<p>3.在主类中创建线程进行测试。考虑线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String accountId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">equals</span><span class="params">(Account b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.accountId==b.accountId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Withdrawer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        synchronize(account)&#123;</span><br><span class="line">            account.setBalance(account.getBalance()-money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Account account = <span class="keyword">new</span> Account(<span class="string">&quot;1234567&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">		Withdrawer t1 = <span class="keyword">new</span> Withdrawer( account, <span class="number">8000</span>);</span><br><span class="line">		Withdrawer t2 = <span class="keyword">new</span> Withdrawer( account, <span class="number">2800</span>);</span><br><span class="line">		Thread(t1,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">		Thread(t2,<span class="string">&quot;小明的妻子&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-CyclicBarrier、CountDownLatch、Semaphore-的用法"><a href="#9-CyclicBarrier、CountDownLatch、Semaphore-的用法" class="headerlink" title="9.CyclicBarrier、CountDownLatch、Semaphore 的用法"></a>9.CyclicBarrier、CountDownLatch、Semaphore 的用法</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 类位于JUC 包下，利用它可以实现类似计数器的功能。</p>
<p>比如有 一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在执行&quot;</span>);</span><br><span class="line"> 	Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"> 	System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line"> 	latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread()&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在执行&quot;</span>);</span><br><span class="line">	Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"> 	System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line"> 	latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;等待 2 个子线程执行完毕...&quot;</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;2 个子线程已经执行完毕&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;继续执行主线程&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。</p>
<p>叫做回环 是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。</p>
<p>我们暂且把这个状态就叫做 barrier，当调用 await()方法之后，线程就处于 barrier 了。</p>
<p> <strong>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：</strong> </p>
<ol>
<li>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任 务； </li>
<li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有 线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">   CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">      <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">5000</span>); <span class="comment">//以睡眠来模拟线程需要预定写入数据操作</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;写入数据完                                       毕，等待其他线程写入完毕&quot;</span>);</span><br><span class="line"> 				  cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 Semaphore 类中比较重要的几个方法： </p>
<ol>
<li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许 可。 </p>
</li>
<li><p>public void acquire(int permits):获取 permits 个许可 </p>
</li>
<li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 </p>
</li>
<li><p>public void release(int permits) { }:释放 permits 个许可</p>
<p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</p>
</li>
<li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失 败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的 时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p> public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返 回 true，若获取失败，则立即返回 false </p>
</li>
<li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p>
</li>
<li><p>还可以通过 availablePermits()方法得到可用的许可数目。</p>
</li>
</ol>
<p>例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完 了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line"><span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">System.out.println(<span class="string">&quot;工人&quot;</span>+<span class="keyword">this</span>.num+<span class="string">&quot;占用一个机器在生产...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;工人&quot;</span>+<span class="keyword">this</span>.num+<span class="string">&quot;释放出机器&quot;</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不 同；</p>
<p>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时 执行；</p>
<p>另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。  Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<h3 id="10-如何解决CAS的ABA问题"><a href="#10-如何解决CAS的ABA问题" class="headerlink" title="10.如何解决CAS的ABA问题"></a>10.如何解决CAS的ABA问题</h3><p>CAS（compare and swap）的原理是拿期望的值A和原本的内存值V作比较，如果相同则更新成新的值B。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>JDK的atomic包里提供了一个类<strong>AtomicStampedReference</strong>来解决ABA问题。其实就是版本号机制。</p>
<p>如果当前引用 == 预期引用，并且当前标志等于预期标志，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *expectedReference - 该引用的预期值</span></span><br><span class="line"><span class="comment"> *newReference - 该引用的新值</span></span><br><span class="line"><span class="comment"> *expectedStamp - 该标志的预期值</span></span><br><span class="line"><span class="comment"> *newStamp - 该标志的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">        <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Thread refT1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>,</span><br><span class="line">                    atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            log(<span class="string">&quot;thread refT1:&quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">101</span>, <span class="number">100</span>,</span><br><span class="line">                    atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            log(<span class="string">&quot;thread refT1:&quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread refT2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">            log(<span class="string">&quot;before sleep : stamp = &quot;</span> + stamp);    <span class="comment">// stamp = 0</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="string">&quot;after sleep : stamp = &quot;</span> + atomicStampedRef.getStamp());<span class="comment">//stamp = 1</span></span><br><span class="line">            <span class="keyword">boolean</span> c3 = atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            log(<span class="string">&quot;thread refT2:&quot;</span> + atomicStampedRef.getReference() + <span class="string">&quot;,c3 is &quot;</span> + c3);        <span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    refT1.start();</span><br><span class="line">    refT2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String logString)</span> </span>&#123;</span><br><span class="line">    System.out.println(logString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-指令重排序："><a href="#10-指令重排序：" class="headerlink" title="10.指令重排序："></a>10.指令重排序：</h3><p><strong>简单来说，就是指你在程序中写的代码，在执行时并不一定按照写的顺序。</strong></p>
<p>在Java中，JVM能够根据处理器特性（CPU多级缓存系统、多核处理器等）适当对机器指令进行重排序，最大限度发挥机器性能。</p>
<p>参考链接： <a href="https://zhuanlan.zhihu.com/p/138819184">https://zhuanlan.zhihu.com/p/138819184</a></p>
<h3 id="11-session和cookie的区别"><a href="#11-session和cookie的区别" class="headerlink" title="11.session和cookie的区别"></a>11.session和cookie的区别</h3><p>cookie是客户端的，session是服务端的。</p>
<p>cookie存储于客户端，记录web服务器的信息，每次上网时都会先查看对应的cookie信息，比如购物时，使用cookie记录购物车信息。 </p>
<p>session是记录客户机的信息，SessionID是session的唯一标识，使用session可以记录客户端的请求等。</p>
<h2 id="四、IO流"><a href="#四、IO流" class="headerlink" title="四、IO流"></a>四、IO流</h2><h2 id="五、JVM"><a href="#五、JVM" class="headerlink" title="五、JVM"></a>五、JVM</h2><p>主要分为六大块：</p>
<p><strong>①Java内存区域、②JVM内存管理、③虚拟机垃圾收集器、④虚拟机垃圾算法、⑤JVM调优、⑥Java类加载机制</strong></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>这里所说的线程指程序执行过程中的一个线程实体。</p>
<p>JVM 允许一个应用并发执行多个线程。 Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。</p>
<p><font color=#bbbb>当线程本地存储、缓 冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。</font></p>
<p>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时, 会释放原生线程和 Java 线程的所有资源。</p>
<p>Hotspot JVM 后台运行的系统线程主要有下面几个： </p>
<table>
<thead>
<tr>
<th>虚拟机线程 （VM thread）</th>
<th>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当 堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>周期性任务线程</strong></td>
<td>这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</td>
</tr>
<tr>
<td><strong>GC 线程</strong></td>
<td>这些线程支持 JVM 中不同的垃圾回收活动。</td>
</tr>
<tr>
<td><strong>编译器线程</strong></td>
<td>这些线程在运行时将字节码动态编译成本地平台相关的机器码。</td>
</tr>
<tr>
<td><strong>信号分发线程</strong></td>
<td>这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</td>
</tr>
</tbody></table>
<h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>JVM 内存区域主要分为</p>
<ul>
<li><p>线程私有区域：<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code></p>
</li>
<li><p>线程共享区域：<code>JAVA 堆</code>、<code>方法区</code></p>
</li>
<li><p>直接内存：<code>不受JVM GC管理</code></p>
</li>
</ul>
<p><strong>线程私有数据区域</strong> 生命周期与线程相同, <font color=#bbbb>依赖用户线程的启动/结束，而创建/销毁(在 Hotspot VM 内</font>, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。</p>
<p><strong>线程共享区域</strong> <font color=#bbbb>随虚拟机的启动/关闭而创建/销毁。</font></p>
<p><strong>直接内存</strong> <font color=#bbbb>并不是 JVM 运行时数据区的一部分</font>, 但也会被频繁的使用: 例如 NIO 提 供了基于 Channel 与 Buffer 的 IO 方式, 它可以<font color=#bbbb>使用 Native 函数库直接分配堆外内存</font>, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作, 这样就避免了在 Java 堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204182259266.png" alt="image-20220418225937866"></p>
<h4 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h4><p>一块较小的内存空间, <font color=#bbbb>是当前线程所执行的字节码的行号指示器</font>，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。 </p>
<p>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h4 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈(线程私有)"></a>虚拟机栈(线程私有)</h4><p>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204192159839.png" alt="image-20220419215913693" style="zoom:75%;" />

<h4 id="本地方法栈-线程私有"><a href="#本地方法栈-线程私有" class="headerlink" title="本地方法栈(线程私有)"></a>本地方法栈(线程私有)</h4><blockquote>
<p>Native本地方法：</p>
<p>1.JVM的实现，为了与操作系统底层进行交互，就使用了本地方法。<br>2.JVM自己的代码，有一部分使用C实现的，这些代码的使用也需要使用本地方法。</p>
</blockquote>
<p>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为 Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个 C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</p>
<h4 id="堆（Heap-线程共享）"><a href="#堆（Heap-线程共享）" class="headerlink" title="堆（Heap-线程共享）"></a>堆（Heap-线程共享）</h4><p><strong>又称运行时数据区。</strong>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以 细分为: <font color=#bbbb>新生代【Eden 区、From Survivor 区、 To Survivor 区】和老年代。</font></p>
<h4 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h4><p>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. </p>
<p><font color=#bbbb>HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区</font>, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对常量池的回收和类型 的卸载, 因此收益一般很小)。 </p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版 本、字段、方法、接口等描述等信息外，还有一项信息是常量池 ，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。</p>
<p> Java 虚拟机对 Class 文件的每一部分（自然也包括常量 池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会 被虚拟机认可、装载和执行。</p>
<h3 id="运行时内存"><a href="#运行时内存" class="headerlink" title="运行时内存"></a>运行时内存</h3><p>Java 堆从 GC 的角度还可以细分为: 新生代【Eden 区、From Survivor 区、 To Survivor 区】和老年 代。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204192353112.png" alt="image-20220419235356742"></p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。</p>
<p><strong>Eden区：</strong></p>
<p><strong>FromSurviror区：</strong> </p>
<p><strong>ToSurvivor区</strong> </p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h3 id="Java-对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）"><a href="#Java-对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）" class="headerlink" title="Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）"></a>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</h3><h3 id="对象的访问定位的两种方式（句柄和直接指针两种方式）"><a href="#对象的访问定位的两种方式（句柄和直接指针两种方式）" class="headerlink" title="对象的访问定位的两种方式（句柄和直接指针两种方式）"></a>对象的访问定位的两种方式（句柄和直接指针两种方式）</h3><h3 id="拓展问题-String类和常量池"><a href="#拓展问题-String类和常量池" class="headerlink" title="拓展问题: String类和常量池"></a>拓展问题: String类和常量池</h3><h3 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如何判断对象是否死亡（两种方法）。 </p>
<p>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好 处）。 </p>
<p>如何判断一个常量是废弃常量 </p>
<p>如何判断一个类是无用的类 </p>
<h3 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a>垃圾收集有哪些算法，各自的特点？</h3><p> HotSpot为什么要分为新生代和老年代？ </p>
<h3 id="常见的垃圾回收器有那些？"><a href="#常见的垃圾回收器有那些？" class="headerlink" title="常见的垃圾回收器有那些？"></a>常见的垃圾回收器有那些？</h3><p>介绍一下CMS,G1收集器。 </p>
<p>Minor GC 和 Full GC 有什么不同呢？</p>
<h3 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h3><h2 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h2><h3 id="１-Bean的生命周期"><a href="#１-Bean的生命周期" class="headerlink" title="１.Bean的生命周期"></a>１.Bean的生命周期</h3><p>创建、</p>
<p>IOC注入、</p>
<p>getBeanName、</p>
<p>BeanNameFactory、</p>
<p>ApplicationContextAware、</p>
<p>PostConstructBeforeInitiation、</p>
<p>init、</p>
<p>PostConstructAfterInitiation、</p>
<p>destroy</p>
<h3 id="２-SpringMVC的工作原理？"><a href="#２-SpringMVC的工作原理？" class="headerlink" title="２.SpringMVC的工作原理？"></a>２.SpringMVC的工作原理？</h3><ul>
<li>用户向服务器发送请求，通过server.xml文件，请求被前端控制器DispatchServlet捕获；</li>
<li>DispatchServlet对URL进行解析，得到请求资源标识符（URI），通过HandlerMapping找到合适的处理器HandlerExcutionChain;</li>
<li>根据得到的处理器，DispatchServlet选择合适的适配器handlerAdapter处理请求；</li>
<li>handler处理完请求后，返回一个ModelAndView对象给DispatchServlet；</li>
<li>DispatchServlet将此对象通过ViewResolver进行处理，并得到渲染视图；</li>
<li>最后将Model中的参数进行解析，最终呈现出完整的视图返回给客户端；</li>
</ul>
<h3 id="３-常用注解有哪些？"><a href="#３-常用注解有哪些？" class="headerlink" title="３.常用注解有哪些？"></a>３.常用注解有哪些？</h3><h3 id="４-谈谈你对Spring的理解"><a href="#４-谈谈你对Spring的理解" class="headerlink" title="４.谈谈你对Spring的理解"></a>４.谈谈你对Spring的理解</h3><p>Spring是一个开源框架，为简化企业级应用开发而生，Spring是一个IOC和AOP容器框架</p>
<h3 id="５-Spring容器的主要核心是："><a href="#５-Spring容器的主要核心是：" class="headerlink" title="５.Spring容器的主要核心是："></a>５.Spring容器的主要核心是：</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050318374.png" alt="Spring的设计模式"></p>
<h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><h3 id="mysql和oracle的区别"><a href="#mysql和oracle的区别" class="headerlink" title="mysql和oracle的区别"></a>mysql和oracle的区别</h3><h3 id="innoDB和MyIsam的区别"><a href="#innoDB和MyIsam的区别" class="headerlink" title="innoDB和MyIsam的区别"></a>innoDB和MyIsam的区别</h3><h3 id="慢查询的原因"><a href="#慢查询的原因" class="headerlink" title="慢查询的原因"></a>慢查询的原因</h3><h3 id="行级锁表级锁"><a href="#行级锁表级锁" class="headerlink" title="行级锁表级锁"></a>行级锁表级锁</h3><h3 id="1-sql注入是什么？-和-的区别是什么"><a href="#1-sql注入是什么？-和-的区别是什么" class="headerlink" title="1.sql注入是什么？#{}和${}的区别是什么?"></a>1.sql注入是什么？#{}和${}的区别是什么?</h3><p>sql注入是指通过web表单输入恶意sql语句，激发数据库漏洞，而不是按设计者意图去执行sql语句。举例：select * from def_user where username=” <u>admin “  or  “a”=”a</u> “恒成立；</p>
<p>#{}是通过预编译处理，如select * from user where username=?,sql语义不会发生改变，在很大程度上可以防止sql注入</p>
<p>${}是字符串替换。在处理时，将 它替换成变量的值，不安全。</p>
<h3 id="2-MySQL性能优化有哪些？"><a href="#2-MySQL性能优化有哪些？" class="headerlink" title="2.MySQL性能优化有哪些？"></a>2.MySQL性能优化有哪些？</h3><ul>
<li>使用limit1</li>
<li>选择正确的数据库引擎</li>
<li>用not exists代替not in</li>
<li>对操作符进行优化，尽量不采用索引的操作符</li>
</ul>
<h2 id="四、Mybatis"><a href="#四、Mybatis" class="headerlink" title="四、Mybatis"></a>四、Mybatis</h2><h3 id="1、什么是-Mybatis？"><a href="#1、什么是-Mybatis？" class="headerlink" title="1、什么是 Mybatis？"></a>1、什么是 Mybatis？</h3><p>（1） Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开<br>发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、<br>创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制<br>sql 执行性能，灵活度高。<br>（2） MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成<br>数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果<br>集。<br>（3） 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通<br>过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql<br>语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。<br>（从执行 sql 到返回 result 的过程）。</p>
<h2 id="五、Redis"><a href="#五、Redis" class="headerlink" title="五、Redis"></a>五、Redis</h2><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050319649.png"></p>
<h2 id="六、RabbitMQ"><a href="#六、RabbitMQ" class="headerlink" title="六、RabbitMQ"></a>六、RabbitMQ</h2><h3 id="1、什么是rabbitmq？"><a href="#1、什么是rabbitmq？" class="headerlink" title="1、什么是rabbitmq？"></a>1、什么是rabbitmq？</h3><p><strong>答：</strong></p>
<p>采用AMQP高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦。</p>
<h3 id="2、为什么要使用rabbitmq？"><a href="#2、为什么要使用rabbitmq？" class="headerlink" title="2、为什么要使用rabbitmq？"></a>2、为什么要使用rabbitmq？</h3><p><strong>答：</strong> 1、在分布式系统下具备异步,削峰,负载均衡等一系列高级功能；</p>
<p>2、拥有持久化的机制，进程消息，队列中的信息也可以保存下来。</p>
<p>3、实现消费者和生产者之间的解耦。</p>
<p>4、对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</p>
<p>5、可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</p>
<h3 id="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"><a href="#4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？" class="headerlink" title="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"></a>4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h3><p>答：<br>发送方确认模式<br>1.将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。<br>2.一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。<br>3.如果 RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。<br>接收方确认机制<br>接收方消息确认机制<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。保证数据的最终一致性；</p>
<h3 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5.如何避免消息重复投递或重复消费？"></a>5.如何避免消息重复投递或重复消费？</h3><p><strong>答：</strong></p>
<p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；</p>
<p>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID 等）作为去重的依据，避免同一条消息被重复消费。</p>
<h3 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h3><p>一个消息是有死亡状态的，它会被发送到一个指定的队列中，这个队列是一个普通的队列，根据他的功能，我们叫他死信队列。</p>
<h3 id="8、消息怎么路由？"><a href="#8、消息怎么路由？" class="headerlink" title="8、消息怎么路由？"></a>8、消息怎么路由？</h3><p>答：<br>消息提供方-&gt;路由-&gt;一至多个队列<br>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；<br>常用的交换器主要分为一下三种<br>1.fanout：如果交换器收到消息，将会广播到所有绑定的队列上<br>2.direct：如果路由键完全匹配，消息就被投递到相应的队列<br>3.topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符</p>
<h3 id="七、ehcache"><a href="#七、ehcache" class="headerlink" title="七、ehcache"></a>七、ehcache</h3><p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</p>
<p>Spring Cache 是 Spring 提供的一整套的缓存解决方案。虽然它本身并没有提供缓存的实现，但是它提供了一整套的接口和代码规范、配置、注解等，这样它就可以整合各种缓存方案了，比如 Redis、Ehcache，我们也就不用关心操作缓存的细节。</p>
<p>Spring 提供了四个注解来声明缓存规则。@Cacheable，@CachePut，@CacheEvict，@Caching。</p>
<h3 id="八、简历说明"><a href="#八、简历说明" class="headerlink" title="八、简历说明"></a>八、简历说明</h3><p>独立的模块设计+使用count判断是否存在，改为limit 1</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>实践知识整理</title>
    <url>/2021/08/03/%E5%AE%9E%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="知识内容"><a href="#知识内容" class="headerlink" title="知识内容"></a>知识内容</h1><h2 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h2><h3 id="什么是HTTP请求头-响应头"><a href="#什么是HTTP请求头-响应头" class="headerlink" title="什么是HTTP请求头/响应头"></a>什么是HTTP请求头/响应头</h3><p>1)请求(客户端-&gt;服务端[request])<br>     GET(请求的方式)     /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)<br>     Accept: <em>/</em>(客户端能接收的资源类型)<br>     Accept-Language: en-us(客户端接收的语言类型)<br>     Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>     Host: localhost:8080(连接的目标主机和端口号)<br>     Referer: <a href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>     User-Agent: Mozilla/4.0(客户端版本号的名字)<br>     Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>     If-Modified-Since: Tue, 11 Jul     2000 18:23:51 GMT(缓存时间)<br>     Cookie(客户端暂存服务端的信息)<br>     Date: Tue, 11 Jul 2000     18:23:51 GMT(客户端请求服务端的时间)  </p>
<span id="more"></span>

<p>2)响应(服务端-&gt;客户端[response])<br>​        HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)<br>​     Location:     <a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a>(服务端需要客户端访问的页面路径)<br>​     Server:apache     tomcat(服务端的Web服务端名)<br>​     Content-Encoding:     gzip(服务端能够发送压缩编码类型)<br>​     Content-Length: 80(服务端发送的压缩数据的长度)<br>​     Content-Language: zh-cn(服务端发送的语言类型)<br>​     Content-Type:     text/html; charset=GB2312(服务端发送的类型及采用的编码方式)<br>​     Last-Modified:     Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)<br>​     Refresh:     1;url=<a href="https://link.zhihu.com/?target=http://www.it315.org">http://www.it315.org</a>(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)<br>​     Content-Disposition: attachment;     filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)<br>​     Transfer-Encoding:     chunked(分块传递数据到客户端）<br>​     Set-Cookie:SS=Q0=5Lb_nQ;     path=/search(服务端发送到客户端的暂存数据)<br>​     Expires:     -1//3种(服务端禁止客户端缓存页面数据)<br>​     Cache-Control:     no-cache(服务端禁止客户端缓存页面数据)<br>​     Pragma: no-cache(服务端禁止客户端缓存页面数据)<br>​     Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  </p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="1-匿名内部类"><a href="#1-匿名内部类" class="headerlink" title="1.匿名内部类"></a>1.匿名内部类</h3><p>匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：<strong>必须继承一个父类或实现一个接口</strong></p>
<h4 id="实例1-不使用匿名内部类来实现抽象方法"><a href="#实例1-不使用匿名内部类来实现抽象方法" class="headerlink" title="实例1:不使用匿名内部类来实现抽象方法"></a>实例1:不使用匿名内部类来实现抽象方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p>
<p>但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类</p>
<h4 id="实例2：匿名内部类的基本实现"><a href="#实例2：匿名内部类的基本实现" class="headerlink" title="实例2：匿名内部类的基本实现"></a>实例2：匿名内部类的基本实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p>
<p>这样便可以省略一个类的书写,并且，匿名内部类还能用于接口上</p>
<h4 id="实例3：在接口上使用匿名内部类"><a href="#实例3：在接口上使用匿名内部类" class="headerlink" title="实例3：在接口上使用匿名内部类"></a>实例3：在接口上使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>由上面的例子可以看出，<strong>只要一个类是抽象的或是一个接口</strong>，那么其子类中的方法都可以使用匿名内部类来实现</p>
<h3 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h3><p>对于单方法接口，即一个接口只定义了一种方法，我们可以只写出方法定义：</p>
<p>即简化匿名内部类的方式，<strong>其核心是一个接口实现类的覆盖重写，返回一个接口对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后</span></span><br><span class="line">Person p = ()-&gt;System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure>

<h3 id="3-联系与区别"><a href="#3-联系与区别" class="headerlink" title="3.联系与区别"></a>3.联系与区别</h3><ul>
<li>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可；但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例；但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法；但 Lambda 表达式的代码块不允许调用接口中定义的默认方法。</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h3><p><img src="https://img-blog.csdn.net/20131213145346421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p5XzE5ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="Data-Manipulation-Language"><a href="#Data-Manipulation-Language" class="headerlink" title="Data Manipulation Language"></a>Data Manipulation Language</h3><h4 id="连接词："><a href="#连接词：" class="headerlink" title="连接词："></a>连接词：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">&#x27;name_%&#x27;</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">between</span> <span class="string">&#x27;100&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;150&#x27;</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">in</span> (column1,column2...)</span><br></pre></td></tr></table></figure>

<h4 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">%:任意字符</span></span><br><span class="line"><span class="string">_:任意单个字符</span></span><br><span class="line">[ ]<span class="string">:指定范围</span> <span class="string">([a-f])</span> <span class="string">或集合</span> <span class="string">([abcdef])</span> <span class="string">中的任何单个字符</span></span><br><span class="line">[<span class="string">^</span>]<span class="string">:不属于指定范围</span> <span class="string">([a-f])</span> <span class="string">或集合</span> <span class="string">([abcdef])</span> <span class="string">的任何单个字符</span></span><br><span class="line"><span class="string">escape</span> <span class="string">&#x27;\&#x27;：转义,select * from table where name like &#x27;</span><span class="string">user\_&#x27;</span> <span class="string">escape</span> <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="限定词"><a href="#限定词" class="headerlink" title="限定词:"></a>限定词:</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">distinct:唯一值</span></span><br><span class="line"><span class="string">order</span> <span class="string">by：排序规则，desc/asc</span></span><br><span class="line"><span class="string">group</span> <span class="string">by:分组.having</span> <span class="string">group_conditon</span></span><br><span class="line"><span class="string">limit</span> <span class="string">nums:限制个数</span></span><br><span class="line"><span class="string">offset</span> <span class="string">nums:从第几个开始</span></span><br><span class="line"><span class="string">Is</span> <span class="string">Not/Is</span> <span class="literal">NULL</span><span class="string">:判空</span></span><br></pre></td></tr></table></figure>

<h4 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">table</span> A </span><br><span class="line"><span class="keyword">inner</span><span class="operator">/</span><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span><span class="operator">/</span><span class="keyword">full</span> </span><br><span class="line"><span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">Table</span> B </span><br><span class="line"><span class="keyword">on</span> conditions</span><br></pre></td></tr></table></figure>

<h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行函数:</span><br><span class="line">    字符函数、数值函数、日期函数、转换函数、通用函数</span><br><span class="line">组合函数:</span><br><span class="line">     count、min、max、avg、sum</span><br></pre></td></tr></table></figure>

<h3 id="Data-Define-Language"><a href="#Data-Define-Language" class="headerlink" title="Data Define Language"></a>Data Define Language</h3><h4 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h4><p>用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束</p>
<h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">create table if not exits MyTable&#123;</span><br><span class="line">    column1 DATATYPE TABLECONSTRAINT <span class="keyword">DEFAULT</span> default_value,</span><br><span class="line">    column2 DATATYPE TABLECONSTRAINT <span class="keyword">DEFAULT</span> default_value,</span><br><span class="line">&#125;</span><br><span class="line">DATATYPE:</span><br><span class="line">    <span class="type">Integer</span>,<span class="type">boolean</span></span><br><span class="line">TABLECONSTRAINT:</span><br><span class="line">    <span class="keyword">primary</span> keys,autoincrement,<span class="keyword">unique</span>,<span class="keyword">not</span> <span class="keyword">null</span>,<span class="keyword">check</span>,<span class="keyword">foreign</span>      key</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> MyTable</span><br><span class="line">① <span class="keyword">add</span> <span class="keyword">column</span> datatype tableconstraint <span class="keyword">default</span> default_value</span><br><span class="line">② <span class="keyword">drop</span> column_to_be_deleted</span><br><span class="line">③ rename <span class="keyword">to</span> new_table_name</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> MyTable</span><br></pre></td></tr></table></figure>

<h3 id="Data-Control-Language"><a href="#Data-Control-Language" class="headerlink" title="Data Control Language"></a>Data Control Language</h3><p>数据库控制语言：授权，角色控制等</p>
<ul>
<li><p>GRANT – 为用户赋予访问权限</p>
</li>
<li><p>REVOKE – 撤回授权权限</p>
</li>
</ul>
<h3 id="Transaction-Control-Language"><a href="#Transaction-Control-Language" class="headerlink" title="Transaction Control Language"></a>Transaction Control Language</h3><p>事务的概念：要么全部执行，要么全部不执行。<br>​事务的acid属性：atomicity、consistency、isolation、durability<br>​事务的创建：隐式事务、显示事务。事务具有明显的开启和结束标记。</p>
<h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="1-GitFlow"><a href="#1-GitFlow" class="headerlink" title="1. GitFlow"></a>1. GitFlow</h2><p>可以在idea里面直接看到流程：<strong>提交需要反复确认，然后进行拉取</strong></p>
<p><img src="assets/image-20210818173247374.png" alt="image-20210818173247374"></p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>master</strong></td>
<td align="left">存放随时可供生产环境中的部署的代码</td>
</tr>
<tr>
<td align="left"><strong>develop</strong></td>
<td align="left">存放当前最新开发成果的分支，当代码足够稳定时可以合并到master分支上去。</td>
</tr>
<tr>
<td align="left"><strong>feature</strong></td>
<td align="left">开发新功能使用，最终合并到develop分支或抛弃掉</td>
</tr>
<tr>
<td align="left"><strong>release</strong></td>
<td align="left">做小的缺陷修正、准备发布版本所需的各项说明信息</td>
</tr>
<tr>
<td align="left"><strong>hotfix</strong></td>
<td align="left">代码的紧急修复工作</td>
</tr>
</tbody></table>
<p>查看Git工作区、暂存区的变更情况（可以知道哪些没有commit、哪些没有被Git追踪）：<code>git status</code></p>
<p>拉取远程最新的变更到本地：<code>git fetch</code></p>
<p>切换分支：<code>git checkout 分支名</code></p>
<p>将代码还原到某个版本(包括工作目录)：<code>git reset --hard 版本号</code></p>
<p>查看Git的提交(commit)记录：<code>git log</code></p>
<p>将代码还原到某个版本后，后悔了，想重新回去，但在提交记录已经找不到了。<code>git reset --hard</code> 把<code>reset 之后的 commit</code>都给抹杀掉了。找到最近的执行Git命令：<code>git reflog</code></p>
<p>还原到某个版本了，现在我为了稳健，不想再原来的分支上修改了，再<strong>新建一个分支</strong>吧（<code>-b</code> 参数把当前分支切换到了要创建的分支上）：<code>git checkout -b 分支名</code></p>
<p>我们把上一次还是”相对稳健“的分支合并到我新建的分支上：<code>git merge 分支</code></p>
<p>突然想看看现在有多少个分支：<code>git branch -a</code></p>
<p>新增几个文件了，随手<code>git add</code>一下吧</p>
<p>改得差不多了，随手<code>git commit -m</code>一下吧，最好还是<strong>写好备注</strong>，不然以后等改多了，你都不知道你改了什么啦。</p>
<p>改完了，提交到远程吧：<code>git push</code></p>
<p>想把远程分支最新的代码给拉下来，然后合并到本地上。我们可以用<code>git fetch</code>和<code>git merge</code>来实现，也可以通过<code>git pull</code>来实现。一般我用的都是<code>git fetch</code>+<code>git merge</code>，这样会更加<strong>可控</strong>一些</p>
<p>有的时候，本地分支在master分支，然后忘了切其他的分支去修改，直接在master改了，然后也push到远程了。等你发现的时候，你会真的想骂自己。</p>
<p>咋办？最简单的办法其实我们还是可以<code>git reset --hard</code>到对应的版本，然后将其修改或者复原，再强制提交到<code>master</code>分支：<code>git push -u origin/master -f</code></p>
<h2 id="2-idea-插件"><a href="#2-idea-插件" class="headerlink" title="2. idea 插件"></a>2. idea 插件</h2><h3 id="2-1-RestfulToolkit—RESTful服务开发"><a href="#2-1-RestfulToolkit—RESTful服务开发" class="headerlink" title="2.1 RestfulToolkit—RESTful服务开发"></a>2.1 RestfulToolkit—RESTful服务开发</h3><ul>
<li>2.1.1 根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li>
<li>2.1.2 提供了一个 Services tree 的显示窗口;</li>
<li>2.1.3 一个简单的 http 请求工具;</li>
<li>2.1.4 在请求方法上添加了有用功能: 复制生成 URL;复制方法参数…</li>
<li>2.1.5 其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。</li>
</ul>
<h3 id="2-2-快捷键"><a href="#2-2-快捷键" class="headerlink" title="2.2 快捷键"></a>2.2 快捷键</h3><p><code>Ctrl+Shift+Enter</code>   完善整条语句、分号、if语句等</p>
<p><code>Ctrl+W</code>   扩大选取范围</p>
<p><code>Ctrl+F8 </code>  打断点</p>
<p><code>Shift+F9</code>   debug</p>
<p><code>F7 F8 F9</code>   进入方法、下一步、下个断点</p>
<p>ctrl+T 直接拉取git更新</p>
<p>ctrl+alt+shift+C  copy reference</p>
<h1 id="用户评级-项目"><a href="#用户评级-项目" class="headerlink" title="用户评级 项目"></a>用户评级 项目</h1><h2 id="PageInfo"><a href="#PageInfo" class="headerlink" title="PageInfo"></a>PageInfo</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Request URL: </span><br><span class="line">/api/audiences?orderColumn=createTime&amp;orderType=desc&amp;page=1&amp;pagesize=30&amp;readState=READ_SUCCESS</span><br></pre></td></tr></table></figure>

<p>读取过程 : PageInterceptor.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageInfo page = <span class="keyword">new</span> PageInfo();</span><br><span class="line">            page.setCurrent(<span class="keyword">this</span>.getIntValue(request, <span class="string">&quot;page&quot;</span>, <span class="number">1</span>));</span><br><span class="line">            page.setPagesize(<span class="keyword">this</span>.getIntValue(request, <span class="string">&quot;pagesize&quot;</span>, annotation.size()));</span><br><span class="line">            String orderColumn = request.getParameter(<span class="string">&quot;orderColumn&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="项目组件"><a href="#项目组件" class="headerlink" title="项目组件"></a>项目组件</h2><ul>
<li><p>parent : crius</p>
</li>
<li><p>被dependencyManagement管理版本号的组件 :  </p>
<p>opencv、log4j、reflections 、 lombok 、compress 、commons-jcs-core 、kryo 、httpclient 、mapstruct 、aws-java-sdk-s3 、com.amazonaws 、jmespath-java 、commons-collections 、spring-cloud-dependencies 、dependencies </p>
</li>
<li><p>har-manager模块组件：</p>
<p>spring-cloud-starter-openfeign 、spring-cloud-starter-netflix-hystrix 、spring-boot-starter-cache 、ehcache、crius-spring-boot-starter 、mybatis 、crius-oss-amazon-s3-spring-boot-starter 、crius-oss-azure-storage-spring-boot-starter 、jmespath-java 、commons-collections、spring-boot-starter-actuator 、spring-boot-starter-rabbitmq 、spring-cloud-starter-alibaba-nacos-config</p>
</li>
</ul>
<h2 id="Oauth授权"><a href="#Oauth授权" class="headerlink" title="Oauth授权"></a>Oauth授权</h2><p>1.网关拦截</p>
<p>由devops平台上的网关决定redirect地址，Oauth进行授权鉴权，如没有权限，用户拿着token去访问第三方平台</p>
<p>注：微服务技术解决方案下的，网关至少需要具备图示基本功能。</p>
<ol>
<li>网关作为单点入口，完成统一的请求管理</li>
<li>免去客户端直接对接众多微服务的复杂性，采用单点入口，实现路由转发，从而实现服务调用</li>
<li>服务对于整个系统来讲，是不稳定的，那么网关，需要进行限流熔断，保持系统的稳定与分区容错性</li>
<li>对于服务调用的链路，网关有职责进行记录，日志监控，保证整个系统，在监控下工作</li>
<li>系统可能不仅仅是由自有客户端调用，很多时候，系统开放能力API给外部，因此网关需要安全认证，来保证安全</li>
</ol>
<p>2.Security授权</p>
<p>Security通过authLoginFilter同步hac用户信息</p>
<h2 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h2><ul>
<li><p>父pom需要添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>。</p>
</li>
<li><p>父pom需要用<code>&lt;modules&gt;&lt;module&gt;子module名&lt;/module&gt;&lt;/modules&gt;</code>注明子module有哪些。</p>
</li>
<li><p>父pom声明依赖时<code>&lt;dependencies&gt;</code>外要嵌套<code>&lt;dependencyManagement&gt;</code>才能被子pom继承到，我就是忘了这点。</p>
</li>
<li><p>子pom需要通过<code>&lt;parent&gt;&lt;/parent&gt;</code>指定父项目，声明依赖时就默认会用父pom中的版本了。</p>
</li>
</ul>
<h2 id="项目创建顺序"><a href="#项目创建顺序" class="headerlink" title="项目创建顺序"></a>项目创建顺序</h2><p>业务  - &gt;  授权  - &gt;  性能优化</p>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><ul>
<li>entity\dao\mapper\vo写在repository中</li>
<li>service\特有的entity写在特定的module中</li>
</ul>
<h2 id="MyBatis枚举类映射"><a href="#MyBatis枚举类映射" class="headerlink" title="MyBatis枚举类映射"></a>MyBatis枚举类映射</h2><p><strong>mybatis默认的枚举类型处理器 :</strong></p>
<ul>
<li><p>EnumTypeHandler<br>mybatis的默认枚举类型处理器，将枚举类型的name持久化到数据库；</p>
</li>
<li><p>EnumOrdinalTypeHandler<br>mybatis原生支持的另一种枚举类型处理器，将枚举类型的索引序号持久化到数据库，需要全局配置或者在需要的字段上单独配置；</p>
</li>
</ul>
<p><strong>mybatis配置全局默认枚举类型处理器 :  defaultEnumTypeHandler</strong></p>
<ul>
<li>mybatis在3.4.5及之后版本中，新增了一个指定全局默认枚举类型处理器的配置项 :  <strong>default-enum-type-handler</strong><br>在mybatis-config.xml中添加如下配置即可使自定义处理器全局生效，解决了之前新增枚举都需要单独配置的烦恼；</li>
</ul>
<p><img src="assets/image-20210910184840551.png" alt="image-20210910184840551"></p>
<p><img src="assets/image-20210910184912954.png" alt="image-20210910184912954"></p>
<h2 id="使用TypeHandler将List集合数据存入数据库"><a href="#使用TypeHandler将List集合数据存入数据库" class="headerlink" title="使用TypeHandler将List集合数据存入数据库"></a>使用TypeHandler将List集合数据存入数据库</h2><p><a href="https://www.dtmao.cc/news_show_785309.shtml">https://www.dtmao.cc/news_show_785309.shtml</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes(value=JdbcType.VARCHAR)</span></span><br><span class="line"><span class="meta">@MappedTypes(List.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToVarchar</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历List类型的入参，转换为JSON格式，使用Statement对象插入数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, List&lt;String&gt; objectList, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(objectList.isEmpty())&#123;</span><br><span class="line">            ps.setString(i,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = JSON.toJSONString(objectList);</span><br><span class="line">        ps.setString(i,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(resultSet.getString(s),<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = resultSet.getString(i);</span><br><span class="line">        <span class="keyword">return</span>  JSON.parseObject(s,<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = callableStatement.getString(i);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(s,<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开发避坑"><a href="#开发避坑" class="headerlink" title="开发避坑"></a>开发避坑</h1><h2 id="1-判空"><a href="#1-判空" class="headerlink" title="1.判空"></a>1.判空</h2><ul>
<li><p>Constant.equals(Variables);</p>
</li>
<li><p>Java中判断list为空(CollectionUtils.isEmpty)等同于 (list==null&amp;&amp;list.isEmpty())</p>
</li>
</ul>
<h2 id="2-typeHandler匹配问题"><a href="#2-typeHandler匹配问题" class="headerlink" title="2.typeHandler匹配问题"></a>2.typeHandler匹配问题</h2><ul>
<li>使用typeHandler去数据库中查询匹配时，注意序列化和反序列化的问题，需要二者hashcode完全一致，所以最好还是从数据库中找出json，映射为实体对象，在判断是否匹配</li>
<li>错误示例： select语句中，即使数据库中json内容一致，但仍旧不能匹配</li>
<li><img src="assets/image-20211116161549936.png" alt="image-20211116161549936"></li>
</ul>
<h1 id="隐私条款项目"><a href="#隐私条款项目" class="headerlink" title="隐私条款项目"></a>隐私条款项目</h1><h2 id="1-定时任务"><a href="#1-定时任务" class="headerlink" title="1.定时任务"></a>1.定时任务</h2><p><strong>- @SchedulerLock注解：为方法加上锁。</strong></p>
<p>name属性（锁的名称）必须指定，每次只能执行一个具有相同名字的任务。</p>
<p><strong>- lockAtMostFor属性，指定执行节点死亡时应该保留锁的时间。</strong></p>
<p>设置锁的最大持有时间,为了解决如果持有锁的节点挂了,无法释放锁,其他节点无法进行下一次任务。设置了最大持有时间，当持有时间到了自动释放锁，不影响下一次执行。</p>
<p><strong>- lockAtLeastFor属性，指定保留锁的最短时间。</strong></p>
<p>主要目的是在任务非常短的且节点之间存在时钟差异的情况下防止多个节点执行。这个属性是锁的持有时间。设置了多少就一定会持有多长时间，在此期间，下一次任务执行时，其他节点包括它本身是不会执行任务的。</p>
<h2 id="2-隐私条款模板"><a href="#2-隐私条款模板" class="headerlink" title="2.隐私条款模板"></a>2.隐私条款模板</h2><p>接口文档</p>
<ul>
<li>查看模板   GET     /api/templates</li>
<li>新建模板   POST    /api/templates</li>
<li>编辑模板  PATCH  /api/templates/{templateId}</li>
<li>删除模板  DELETE    /api/templates/{templateId}</li>
</ul>
<h2 id="3-校验"><a href="#3-校验" class="headerlink" title="3.校验"></a>3.校验</h2><ul>
<li>@Unique   name字段一致，表示绑定在一起校验<img src="assets/image-20211104145855450.png" alt="image-20211104145855450"></li>
</ul>
<h2 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4.特殊用法"></a>4.特殊用法</h2><ul>
<li>```java<br>/**<ul>
<li>则在路径中悄悄接收projectIds</li>
<li>/<br>@JsonIgnore<br>private List<Long> projectIds;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 通过一系列Id查找</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;xml</span><br><span class="line">  &lt;select id&#x3D;&quot;getClauses&quot; resultType&#x3D;&quot;long&quot;&gt;</span><br><span class="line">      select id from def_privacy_clause where project_id in</span><br><span class="line">      &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot;&gt;</span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      &lt;&#x2F;foreach&gt;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-部署踩坑"><a href="#3-部署踩坑" class="headerlink" title="3.部署踩坑"></a>3.部署踩坑</h2><h4 id="1-消息已发，计算端没有日志"><a href="#1-消息已发，计算端没有日志" class="headerlink" title="(1)消息已发，计算端没有日志"></a>(1)消息已发，计算端没有日志</h4><ul>
<li><p>检查MQ配置</p>
</li>
<li><p>检查消费者</p>
</li>
<li><p>计算端磁盘已满</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据管理与分析 - 基础知识</title>
    <url>/2022/04/09/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90(1)/</url>
    <content><![CDATA[<h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>存储的格式可以直观地反映实体间的关系。SQL表达能力很强。</p>
<h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>（1）键值对存储（key-value）：代表软件Redis，它的优点能够进行数据的快速查询，而缺点是需要存储数据之间的关系。</p>
<p>（2）列存储：代表软件Hbase，它的优点是对数据能快速查询，数据存储的扩展性强。而缺点是数据库的功能有局限性。</p>
<p>（3）文档数据库存储：代表软件MongoDB，它的优点是对数据结构要求不特别的严格。而缺点是查询性的性能不好，同时缺少一种统一查询语言。</p>
<p>（4）图形数据库存储：代表软件InfoGrid，它的优点可以方便的利用图结构相关算法进行计算。而缺点是要想得到结果必须进行整个图的计算，而且遇到不适合的数据模型时，图形数据库很难使用。</p>
<span id="more"></span>

<h4 id="数据库的需求变化"><a href="#数据库的需求变化" class="headerlink" title="数据库的需求变化"></a>数据库的需求变化</h4><p>数据量和负载激增</p>
<ul>
<li>扩展性变得更重要</li>
<li>性价比变得更重要</li>
</ul>
<p>云计算的普及</p>
<ul>
<li>易用性变得更重要</li>
</ul>
<h4 id="关系型数据库的查询执行过程"><a href="#关系型数据库的查询执行过程" class="headerlink" title="关系型数据库的查询执行过程"></a>关系型数据库的查询执行过程</h4><p>SQL –&gt; AST（解析树）–&gt; <font color=#bbbb>PLANS（查询计划）–&gt; BEST PLAN –&gt; 执行 –&gt; RESULTS</font></p>
<h5 id="一、语法解析器和预处理器"><a href="#一、语法解析器和预处理器" class="headerlink" title="一、语法解析器和预处理器"></a>一、语法解析器和预处理器</h5><p>1.MySQL解析器通过关键字将SQL语句进行解析，并生成对应的解析树；</p>
<p>2.MySQL解析器将使用MySQL语法规则验证和解析查询，eg：验证是否使用错误的关键字、使用关键字的顺序是否正确、验证引号是否前后匹配等；</p>
<p>3.预处理器根据一些MySQL规则进行进一步检查解析树是否合法，eg：检查数据表和数据列是否存在，解析名字和别名是否有歧义；</p>
<p>4.下一步预处理器验证用户权限，查看用户是否有操作权限，通常很快；</p>
<h5 id="二、查询优化器"><a href="#二、查询优化器" class="headerlink" title="二、查询优化器"></a>二、查询优化器</h5><p>1.优化器的作用就是找到最好的执行计划；</p>
<p>2.语法树被认为是合法后，优化器将MySQL语句转换为执行计划，一条查询可以有多种执行方式，最后都返回相同的结果；</p>
<p>3.生成执行计划过程</p>
<p>4.MySQL使用基于成本的优化器（CBO cost-based optimizer），会预测一个查询使用某种执行计划的成本，选择其中成本最小的一个；</p>
<p>5.导致MySQL优化器选择非最优执行计划的原因</p>
<p>6.MySQL可以处理的优化类型</p>
<h5 id="三、EXAMPLE"><a href="#三、EXAMPLE" class="headerlink" title="三、EXAMPLE:"></a>三、EXAMPLE:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="SQL的执行过程："><a href="#SQL的执行过程：" class="headerlink" title="SQL的执行过程："></a>SQL的执行过程：</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">FROM</span> ：作笛卡尔积</span><br><span class="line"># <span class="keyword">WHERE</span>：过滤</span><br><span class="line"># <span class="keyword">GROUP</span> <span class="keyword">BY</span>：分组</span><br><span class="line"># <span class="keyword">HAVING</span>：过滤</span><br><span class="line"># <span class="keyword">SELECT</span>：列表</span><br><span class="line"># 执行 <span class="keyword">DISTINCT</span> 子句</span><br><span class="line"># 执行 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句</span><br></pre></td></tr></table></figure>

<p>每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。</p>
<h5 id="四、B-树"><a href="#四、B-树" class="headerlink" title="四、B+树"></a>四、B+树</h5><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下: </p>
<p>(1)每个结点至多有m个子女；</p>
<p>(2)除根结点外，每个结点至少有和∟m/2」个子女，根结点至少有两个子女；</p>
<p>(3)有k个子女的结点必有k个关键字。</p>
<p>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p>
<h5 id="五、列存数据库中的查询计划如何执行"><a href="#五、列存数据库中的查询计划如何执行" class="headerlink" title="五、列存数据库中的查询计划如何执行"></a>五、列存数据库中的查询计划如何执行</h5><p><a href="https://draveness.me/whys-the-design-olap-column-oriented/">https://draveness.me/whys-the-design-olap-column-oriented/</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>数据管理与分析</category>
      </categories>
      <tags>
        <tag>数据管理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据管理与分析 - 事务</title>
    <url>/2022/04/16/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90(2)/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="OLTP-vs-OLAP"><a href="#OLTP-vs-OLAP" class="headerlink" title="OLTP vs OLAP"></a>OLTP vs OLAP</h3><p><strong>1、基本含义不同：</strong><font color=#bbbb>OLTP，即联机事务处理（on-line transaction processing）是传统的关系型数据库的主要应用</font>，主要是基本的、日常的事务处理，记录即时的增、删、改、查，比如在银行存取一笔款，就是一个事务交易。<font color=#bbbb>OLAP，即联机分析处理（On-Line Analytical Processing），是数据仓库的核心部心</font>，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的动态报表系统。<br><strong>2、实时性要求不同：</strong>OLTP实时性要求高，OLTP 数据库旨在使事务应用程序仅写入所需的数据，以便尽快处理单个事务。OLAP的实时性要求不是很高，很多应用顶多是每天更新一下数据。<br><strong>3、数据量不同：</strong>OLTP数据量不是很大，一般只读/写数十条记录，处理简单的事务。OLAP数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据的统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大。<br><strong>4、用户和系统的面向性不同：</strong>OLTP是面向顾客的,用于事务和查询处理。OLAP是面向市场的,用于数据分析。<br><strong>5、数据库设计不同：</strong>OLTP采用实体-联系ER模型和面向应用的数据库设计。OLAP采用星型或雪花模型和面向主题的数据库设计。</p>
<span id="more"></span>

<h3 id="OLTP面对的问题"><a href="#OLTP面对的问题" class="headerlink" title="OLTP面对的问题"></a>OLTP面对的问题</h3><ul>
<li><p>硬件失效    – 宕机/停电     – 硬件损坏       – 灾难</p>
</li>
<li><p>软件错误    – Bug   – 恶意攻击</p>
</li>
<li><p>并发问题    – 多个用户同时更新数据出现异常</p>
</li>
</ul>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>原子性（Atomicity）：要么未开始，要么全部完成，不存在中间状态</p>
<p>一致性（Consistency）：事务的执行不会破坏数据的正确性，即符合约束。</p>
<p>隔离性（Isolation）：多个事务不会互相破坏。常见于并发问题。</p>
<p>持久性（Durability）：一旦提交成功，对数据的修改不会丢失</p>
<h3 id="undolog、redolog、binlog"><a href="#undolog、redolog、binlog" class="headerlink" title="undolog、redolog、binlog"></a>undolog、redolog、binlog</h3><h4 id="Undo日志的规则"><a href="#Undo日志的规则" class="headerlink" title="Undo日志的规则"></a>Undo日志的规则</h4><p>(1) 每一次对数据的改动都需要记录日志。</p>
<p>(2) <strong>日志记录必须在数据之前到达磁盘</strong>。(write ahead logging: WAL)</p>
<p>(3) 事务结束<strong>之前</strong>，所有的数据和日志必须到达磁盘。（保证持久性）</p>
<p>例如：update column A value = value * 2; update column B value = value * 2;</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204161518546.png" alt="image-20220416151835467"></p>
<h4 id="Redo日志的规则"><a href="#Redo日志的规则" class="headerlink" title="Redo日志的规则"></a>Redo日志的规则</h4><p>(1) 每一次对数据的改动都需要记录日志。</p>
<p>(2) <strong>事务提交之前所有的日志必须到达磁盘</strong>。(write ahead logging: WAL)</p>
<p>(3) 事务提交<strong>之后</strong>才能将数据写到磁盘。</p>
<p>(4) 数据到达磁盘后，需在日志中记录END。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202204161525145.png" alt="image-20220416152543073"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>undolog</strong>    用来保证事务回滚和MVCC功能。</p>
<p><strong>redolog</strong>     用来保证事务的持久性、在系统崩溃的时候能保证数据恢复。</p>
<p><strong>binlog</strong>        用于记录数据库执行的写入性操作(不包括查询)信息的二进制日志。是 MySQL的逻辑日志。</p>
<p>更多详细信息：<a href="https://segmentfault.com/a/1190000023827696">https://segmentfault.com/a/1190000023827696</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>数据管理与分析</category>
      </categories>
      <tags>
        <tag>数据管理与分析</tag>
      </tags>
  </entry>
</search>
